<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc,fixuphtml" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Implicitly Declared Classes and Instance main Methods (Second Preview)</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
  <link rel="stylesheet" href="../resources/jdk-default.css" />
  <link rel="stylesheet" href="../resources/spec-changes.css" />
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>

<header id="title-block-header">
<div class="navbar"><div><strong>Java SE 22 & JDK 22</strong></div><nav><ul><li><a href="../api/index.html">API</a>
<li><a href="index.html">OTHER SPECIFICATIONS</a>
<li><a href="man/index.html">TOOL GUIDES</a></ul></nav></div>

<h1 class="title">Implicitly Declared Classes and Instance
<code>main</code> Methods (Second Preview)</h1>
<p class="subtitle">Changes to the Java® Language Specification •
Version 22.0.2+9-70</p>
</header>
<nav id="TOC" role="doc-toc" title="Table Of Contents">
<ul>
<li><a href="#jls-6" id="toc-jls-6">Chapter 6: Names</a>
<ul>
<li><a href="#jls-6.1" id="toc-jls-6.1">6.1 Declarations</a></li>
<li><a href="#jls-6.3" id="toc-jls-6.3">6.3 Scope of a
Declaration</a></li>
<li><a href="#jls-6.7" id="toc-jls-6.7">6.7 Fully Qualified Names and
Canonical Names</a></li>
</ul></li>
<li><a href="#jls-7" id="toc-jls-7">Chapter 7: Packages and Modules</a>
<ul>
<li><a href="#jls-7.3" id="toc-jls-7.3">7.3 Compilation Units</a></li>
<li><a href="#jls-7.6" id="toc-jls-7.6">7.6 Top Level Class and
Interface Declarations</a></li>
</ul></li>
<li><a href="#jls-8" id="toc-jls-8">Chapter 8: Classes</a>
<ul>
<li><a href="#jls-8.1" id="toc-jls-8.1">8.1 Class Declarations</a>
<ul>
<li><a href="#jls-8.1.8" id="toc-jls-8.1.8"><strong>8.1.8 Implicitly
Declared Classes</strong></a></li>
</ul></li>
</ul></li>
<li><a href="#jls-12" id="toc-jls-12">Chapter 12: Execution</a>
<ul>
<li><a href="#jls-12.1" id="toc-jls-12.1">12.1 Java Virtual Machine
Startup</a>
<ul>
<li><a href="#jls-12.1.1" id="toc-jls-12.1.1">12.1.1 Load the
<strong>Initial</strong> Class <strong>or Interface</strong>
<del><code>Test</code></del></a></li>
<li><a href="#jls-12.1.2" id="toc-jls-12.1.2">12.1.2 Link <strong>the
Initial Class or Interface</strong> <del><code>Test</code></del>:
Verify, Prepare, (Optionally) Resolve</a></li>
<li><a href="#jls-12.1.3" id="toc-jls-12.1.3">12.1.3 Initialize
<strong>the Initial Class or Interface</strong> <del>Test</del>: Execute
Initializers</a></li>
<li><a href="#jls-12.1.4" id="toc-jls-12.1.4">12.1.4 Invoke
<del><code>Test.main</code></del> <strong>a <code>main</code>
method</strong></a></li>
</ul></li>
</ul></li>
<li><a href="#jls-13" id="toc-jls-13">Chapter 13: Binary
Compatibility</a>
<ul>
<li><a href="#jls-13.1" id="toc-jls-13.1">13.1 The Form of a
Binary</a></li>
</ul></li>
</ul>
</nav>
<main><p>This document describes changes to the <a
href="https://docs.oracle.com/javase/specs/jls/se21/html">Java Language Specification</a>
to support <em>Implicitly Declared Classes and Instance
<code>main</code> Methods</em>, which is a preview feature of Java SE
22. See <a href="https://openjdk.org/jeps/463">JEP 463</a> for an
overview of the feature.</p>
<p>A <a
href="implicitly-declared-classes-instance-main-methods-jvms.html">companion document</a>
describes the changes needed to the <a
href="https://docs.oracle.com/javase/specs/jvms/se21/html">Java Virtual Machine Specification</a>
to support Implicitly Declared Classes and Instance <code>main</code>
Methods.</p>
<p>Changes are described with respect to existing sections of the JLS.
New text is indicated <strong>like this</strong> and deleted text is
indicated <del>like this</del>. Explanation and discussion, as needed,
is set aside in grey boxes.</p>
<div class="editorial">
<p>Changelog:</p>
<p>2023-11-10: Editorial changes</p>
<p>2023-11-07: Added note regarding the binary name of a top level class
(<a href="#jls-13.1">13.1</a>)</p>
<p>2023-09-27: First draft of second preview. Main changes to first
preview:</p>
<ul>
<li><p>Remove concept of an unnamed class in favour of a simple
compilation unit implicitly declaring a class whose name is determined
by the host system. This class name is never in scope and is not marked
as synthetic.</p></li>
<li><p>Removed the behavioral change that an inherited
<code>static</code> <code>main</code> method would not be considered as
a candidate method.</p></li>
<li><p>Simplified the launcher semantics. Now a candidate method with a
single formal parameter is always preferred over one with no
parameters.</p></li>
</ul>
</div>
<h2 id="jls-6">Chapter 6: Names</h2>
<h3 id="jls-6.1">6.1 Declarations</h3>
<p>A <em>declaration</em> introduces an entity into a program and
includes an identifier (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-3.html#jls-3.8">3.8</a>)
that can be used in a name to refer to this entity. The identifier is
constrained to avoid certain contextual keywords when the entity being
introduced is a class, interface, or type parameter.</p>
<p>A declared entity is one of the following:</p>
<ul>
<li><p>A module, declared in a <code>module</code> declaration (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-7.html#jls-7.7">7.7</a>)</p></li>
<li><p>A package, declared in a <code>package</code> declaration (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-7.html#jls-7.4">7.4</a>)</p></li>
<li><p>An imported class or interface, declared in a single-type-import
declaration or a type-import-on-demand declaration (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-7.html#jls-7.5.1">7.5.1</a>,
<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-7.html#jls-7.5.2">7.5.2</a>)</p></li>
<li><p>An imported <code>static</code> member, declared in a
single-static-import declaration or a static-import-on-demand
declaration (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-7.html#jls-7.5.3">7.5.3</a>,
<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-7.html#jls-7.5.4">7.5.4</a>)</p></li>
<li><p>A class, declared by a normal class declaration (<a
href="#jls-8.1">8.1</a>), an enum declaration (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-8.9">8.9</a>),
<del>or</del> a record declaration (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-8.10">8.10</a>),
<strong>or implicitly by a simple compilation unit (<a
href="#jls-7.3">7.3</a>)</strong></p></li>
<li><p>An interface, declared by a normal interface declaration (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-9.1">9.1</a>)
or an annotation interface declaration (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-9.html#jls-9.6">9.6</a>).</p></li>
<li><p>A type parameter, declared as part of the declaration of a
generic class, interface, method, or constructor (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-8.1.2">8.1.2</a>,
<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-9.html#jls-9.1.2">9.1.2</a>,
<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-8.4.4">8.4.4</a>,
<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-8.8.4">8.8.4</a>)</p></li>
<li><p>A member of a reference type (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-8.2">8.2</a>,
<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-9.html#jls-9.2">9.2</a>,
<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-8.9.3">8.9.3</a>,
<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-9.html#jls-9.6">9.6</a>,
<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-10.html#jls-10.7">10.7</a>),
one of the following:</p>
<ul>
<li><p>A member class (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-8.5">8.5</a>,
<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-9.html#jls-9.5">9.5</a>)</p></li>
<li><p>A member interface (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-8.5">8.5</a>,
<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-9.html#jls-9.5">9.5</a>)</p></li>
<li><p>A field, one of the following:</p>
<ul>
<li><p>A field declared in a class (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-8.3">8.3</a>)</p></li>
<li><p>A field declared in an interface (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-9.html#jls-9.3">9.3</a>)</p></li>
<li><p>An implicitly declared field of a class corresponding to an enum
constant or a record component</p></li>
<li><p>The field <code>length</code>, which is implicitly a member of
every array type (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-10.html#jls-10.7">10.7</a>)</p></li>
</ul></li>
<li><p>A method, one of the following:</p>
<ul>
<li><p>A method (<code>abstract</code> or otherwise) declared in a class
(<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-8.4">8.4</a>)</p></li>
<li><p>A method (<code>abstract</code> or otherwise) declared in an
interface (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-9.html#jls-9.4">9.4</a>)</p></li>
<li><p>An implicitly declared accessor method corresponding to a record
component</p></li>
</ul></li>
</ul></li>
<li><p>An enum constant (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-8.9.1">8.9.1</a>)</p></li>
<li><p>A record component (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-8.10.3">8.10.3</a>)</p></li>
<li><p>A formal parameter, one of the following:</p>
<ul>
<li><p>A formal parameter of a method of a class or interface (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-8.4.1">8.4.1</a>)</p></li>
<li><p>A formal parameter of a constructor of a class (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-8.8.1">8.8.1</a>)</p></li>
<li><p>A formal parameter of a lambda expression (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-15.html#jls-15.27.1">15.27.1</a>)</p></li>
</ul></li>
<li><p>An exception parameter of an exception handler declared in a
<code>catch</code> clause of a <code>try</code> statement (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-14.html#jls-14.20">14.20</a>)</p></li>
<li><p>A local variable, one of the following:</p>
<ul>
<li><p>A local variable declared by a local variable declaration
statement in a block (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-14.html#jls-14.4.2">14.4.2</a>)</p></li>
<li><p>A local variable declared by a <code>for</code> statement or a
<code>try</code>-with-resources statement (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-14.html#jls-14.14">14.14</a>,
<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-14.html#jls-14.20.3">14.20.3</a>)</p></li>
<li><p>A local variable declared by a pattern (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-14.html#jls-14.30.1">14.30.1</a>)</p></li>
</ul></li>
<li><p>A local class or interface (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-14.html#jls-14.3">14.3</a>),
one of the following:</p>
<ul>
<li><p>A local class declared by a normal class declaration</p></li>
<li><p>A local class declared by an enum declaration</p></li>
<li><p>A local class declared by an record declaration</p></li>
<li><p>A local interface declared by a normal interface
declaration</p></li>
</ul></li>
</ul>
<p>Constructors (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-8.8">8.8</a>,
<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-8.10.4">8.10.4</a>)
are also introduced by declarations, but use the name of the class in
which they are declared rather than introducing a new name.</p>
<div class="editorial">
<p>The rest of this section is unchanged.</p>
</div>
<h3 id="jls-6.3">6.3 Scope of a Declaration</h3>
<p>The <em>scope</em> of a declaration is the region of the program
within which the entity declared by the declaration can be referred to
using a simple name, provided it is not shadowed (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-6.html#jls-6.4.1">6.4.1</a>).</p>
<p>A declaration is said to be <em>in scope</em> at a particular point
in a program if and only if the declaration's scope includes that
point.</p>
<p>The scope of the declaration of an observable top level package (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-7.html#jls-7.4.3">7.4.3</a>)
is all observable compilation units associated with modules to which the
package is uniquely visible (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-7.html#jls-7.4.3">7.4.3</a>).</p>
<p>The declaration of a package that is not observable is never in
scope.</p>
<p>The declaration of a subpackage is never in scope.</p>
<p>The package <code>java</code> is always in scope.</p>
<p>The scope of a class or interface imported by a single-type-import
declaration (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-7.html#jls-7.5.1">7.5.1</a>)
or a type-import-on-demand declaration (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-7.html#jls-7.5.2">7.5.2</a>)
is the module declaration (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-7.html#jls-7.7">7.7</a>)
and all the class and interface declarations (<a
href="#jls-8.1">8.1</a>, <a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-9.1">9.1</a>)
of the compilation unit in which the <code>import</code> declaration
appears, as well as any annotations on the module declaration or package
declaration of the compilation unit.</p>
<p>The scope of a member imported by a single-static-import declaration
(<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-7.html#jls-7.5.3">7.5.3</a>)
or a static-import-on-demand declaration (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-7.html#jls-7.5.4">7.5.4</a>)
is the module declaration and all the class and interface declarations
of the compilation unit in which the <code>import</code> declaration
appears, as well as any annotations on the module declaration or package
declaration of the compilation unit.</p>
<p>The scope of a top level class or interface (<a
href="#jls-7.6">7.6</a>) <strong>declared in an ordinary compilation
unit</strong> is all class and interface declarations in the package in
which the top level class or interface is declared.</p>
<p><strong>The implicit declaration of a top level class in a simple
compilation unit (<a href="#jls-7.3">7.3</a>) is never in
scope.</strong></p>
<p>The scope of a declaration of a member <em>m</em> declared in or
inherited by a class or interface <em>C</em> (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-8.2">8.2</a>,
<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-9.html#jls-9.2">9.2</a>)
is the entire body of <em>C</em>, including any nested class or
interface declarations. If <em>C</em> is a record class, then the scope
of <em>m</em> additionally includes the header of the record declaration
of <em>C</em>.</p>
<div class="editorial">
<p>The rest of this section is unchanged.</p>
</div>
<h3 id="jls-6.7">6.7 Fully Qualified Names and Canonical Names</h3>
<p>Every primitive type, named package, top level class, and top level
interface has a <em>fully qualified name</em>:</p>
<ul>
<li><p>The fully qualified name of a primitive type is the keyword for
that primitive type, namely <code>byte</code>, <code>short</code>,
<code>char</code>, <code>int</code>, <code>long</code>,
<code>float</code>, <code>double</code>, or
<code>boolean</code>.</p></li>
<li><p>The fully qualified name of a named package that is not a
subpackage of a named package is its simple name.</p></li>
<li><p>The fully qualified name of a named package that is a subpackage
of another named package consists of the fully qualified name of the
containing package, followed by "<code>.</code>", followed by the simple
(member) name of the subpackage.</p></li>
<li><p>The fully qualified name of a top level class or top level
interface that is declared in an unnamed package is the simple name of
the class or interface.</p>
<blockquote>
<p>In particular, this means that a top level class that is implicitly
declared by a simple compilation unit (<a href="#jls-7.3">7.3</a>) has a
fully qualified name, which is the simple name determined by the host
system (<a href="#jls-8.1.8">8.1.8</a>).</p>
</blockquote></li>
<li><p>The fully qualified name of a top level class or top level
interface that is declared in a named package consists of the fully
qualified name of the package, followed by "<code>.</code>", followed by
the simple name of the class or interface.</p></li>
</ul>
<p>Each member class, member interface, and array type <em>may</em> have
a fully qualified name:</p>
<ul>
<li><p>A member class or member interface <em>M</em> of another class or
interface <em>C</em> has a fully qualified name if and only if
<em>C</em> has a fully qualified name.</p>
<p>In that case, the fully qualified name of <em>M</em> consists of the
fully qualified name of <em>C</em>, followed by "<code>.</code>",
followed by the simple name of <em>M</em>.</p></li>
<li><p>An array type has a fully qualified name if and only if its
element type has a fully qualified name.</p>
<p>In that case, the fully qualified name of an array type consists of
the fully qualified name of the component type of the array type
followed by "<code>[]</code>".</p></li>
</ul>
<p>A local class, local interface, or anonymous class does not have a
fully qualified name.</p>
<p>Every primitive type, named package, top level class, and top level
interface has a <em>canonical name</em>:</p>
<ul>
<li><p>For every primitive type, named package, top level class, and top
level interface, the canonical name is the same as the fully qualified
name.</p>
<blockquote>
<p>In particular, this means that a top level class that is implicitly
declared by a simple compilation unit has a canonical name.</p>
</blockquote></li>
</ul>
<p>Each member class, member interface, and array type <em>may</em> have
a canonical name:</p>
<ul>
<li><p>A member class or member interface <em>M</em> declared in another
class or interface <em>C</em> has a canonical name if and only if
<em>C</em> has a canonical name.</p>
<p>In that case, the canonical name of <em>M</em> consists of the
canonical name of <em>C</em>, followed by "<code>.</code>", followed by
the simple name of <em>M</em>.</p></li>
<li><p>An array type has a canonical name if and only if its component
type has a canonical name.</p>
<p>In that case, the canonical name of the array type consists of the
canonical name of the component type of the array type followed by
"<code>[]</code>".</p></li>
</ul>
<p>A local class, local interface, or anonymous class does not have a
canonical name.</p>
<div class="example">
<p>Example 6.7-1. Fully Qualified Names</p>
<ul>
<li><p>The fully qualified name of the type <code>long</code> is
"<code>long</code>".</p></li>
<li><p>The fully qualified name of the package <code>java.lang</code> is
"<code>java.lang</code>" because it is subpackage <code>lang</code> of
package <code>java</code>.</p></li>
<li><p>The fully qualified name of the class <code>Object</code>, which
is defined in the package <code>java.lang</code>, is
"<code>java.lang.Object</code>".</p></li>
<li><p>The fully qualified name of the interface
<code>Enumeration</code>, which is defined in the package
<code>java.util</code>, is
"<code>java.util.Enumeration</code>".</p></li>
<li><p>The fully qualified name of the type "array of
<code>double</code>" is "<code>double[]</code>".</p></li>
<li><p>The fully qualified name of the type "array of array of array of
array of <code>String</code>" is
"<code>java.lang.String[][][][]</code>".</p></li>
</ul>
<p>In the code:</p>
<pre><code>package points;
class Point    { int x, y; }
class PointVec { Point[] vec; }</code></pre>
<p>the fully qualified name of the type <code>Point</code> is
"<code>points.Point</code>"; the fully qualified name of the type
<code>PointVec</code> is "<code>points.PointVec</code>"; and the fully
qualified name of the type of the field <code>vec</code> of class
<code>PointVec</code> is "<code>points.Point[]</code>".</p>
</div>
<div class="example">
<p>Example 6.7-2. Fully Qualified Names v. Canonical Name</p>
<p>The difference between a fully qualified name and a canonical name
can be seen in code such as:</p>
<pre><code>package p;
class O1 { class I {} }
class O2 extends O1 {}</code></pre>
<p>Both <code>p.O1.I</code> and <code>p.O2.I</code> are fully qualified
names that denote the member class <code>I</code>, but only
<code>p.O1.I</code> is its canonical name.</p>
</div>
<h2 id="jls-7">Chapter 7: Packages and Modules</h2>
<h3 id="jls-7.3">7.3 Compilation Units</h3>
<p><em>CompilationUnit</em> is the goal symbol (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-2.html#jls-2.1">2.1</a>)
for the syntactic grammar (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-2.html#jls-2.3">2.3</a>)
of Java programs. It is defined by the following production:</p>
<dl>
<dt><em>CompilationUnit:</em></dt>
<dd>
<em>OrdinaryCompilationUnit</em>
</dd>
<dd>
<strong><em>SimpleCompilationUnit</em></strong>
</dd>
<dd>
<em>ModularCompilationUnit</em>
</dd>
<dt><em>OrdinaryCompilationUnit:</em></dt>
<dd>
[<em>PackageDeclaration</em>] {<em>ImportDeclaration</em>}
{<em>TopLevelClassOrInterfaceDeclaration</em>}
</dd>
</dl>
<div class="inserted">
<dl>
<dt><em>SimpleCompilationUnit:</em></dt>
<dd>
{<em>ImportDeclaration</em>} {<em>ClassMemberDeclarationNoMethod</em>}
<em>MethodDeclaration</em> {<em>ClassMemberDeclaration</em>}
</dd>
<dt><em>ClassMemberDeclarationNoMethod:</em></dt>
<dd>
<em>FieldDeclaration</em>
</dd>
<dd>
<em>ClassDeclaration</em>
</dd>
<dd>
<em>InterfaceDeclaration</em>
</dd>
<dd>
<code>;</code>
</dd>
</dl>
</div>
<dl>
<dt><em>ModularCompilationUnit:</em></dt>
<dd>
{<em>ImportDeclaration</em>} <em>ModuleDeclaration</em>
</dd>
</dl>
<p>An <em>ordinary compilation unit</em> consists of three parts, each
of which is optional:</p>
<ul>
<li><p>A <code>package</code> declaration (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-7.html#jls-7.4">7.4</a>),
giving the fully qualified name (<a href="#jls-6.7">6.7</a>) of the
package to which the compilation unit belongs.</p>
<p>A compilation unit that has no <code>package</code> declaration is
part of an unnamed package (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-7.html#jls-7.4.2">7.4.2</a>).</p></li>
<li><p><code>import</code> declarations (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-7.html#jls-7.5">7.5</a>)
that allow classes and interfaces from other packages, and
<code>static</code> members of classes and interfaces, to be referred to
using their simple names.</p></li>
<li><p>Top level declarations of classes and interfaces (<a
href="#jls-7.6">7.6</a>).</p></li>
</ul>
<div class="inserted">
<p>A <em>simple compilation unit</em> consists of at least one method
declaration (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-8.4">8.4</a>),
optionally preceded by <code>import</code> declarations. Declarations of
methods, fields, classes, and interfaces are permitted in any order
after the <code>import</code> declarations (if any), as they would be in
a class body (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-8.1.7">8.1.7</a>).</p>
<p>A simple compilation unit implicitly declares a top level class (<a
href="#jls-7.6">7.6</a>) whose members are the methods, fields, classes,
and interfaces declared in the simple compilation unit. The details of
the class are specified in <a href="#jls-8.1.8">8.1.8</a>.</p>
<blockquote>
<p>This means that the following compilation unit is unambiguously an
ordinary compilation unit:</p>
<pre><code>import p.*;
class Test { ... }</code></pre>
<p>whereas the following is unambiguously a simple compilation unit:</p>
<pre><code>import p.*;
static void main(){ ... }
class Test { ... }</code></pre>
</blockquote>
</div>
<p>A <em>modular compilation unit</em> consists of a <code>module</code>
declaration (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-7.html#jls-7.7">7.7</a>),
optionally preceded by <code>import</code> declarations. The
<code>import</code> declarations allow classes and interfaces from
packages in this module and other modules, as well as
<code>static</code> members of classes and interfaces, to be referred to
using their simple names within the <code>module</code> declaration.</p>
<p>Every compilation unit implicitly imports every <code>public</code>
class or interface declared in the predefined package
<code>java.lang</code>, as if the declaration
<code>import java.lang.*;</code> appeared at the beginning of each
compilation unit immediately after any <code>package</code> declaration.
As a result, the names of all those classes and interfaces are available
as simple names in every compilation unit.</p>
<p>The host system determines which compilation units are
<em>observable</em>, except for the compilation units in the predefined
package <code>java</code> and its subpackages <code>lang</code> and
<code>io</code>, which are all always observable.</p>
<p>Each observable compilation unit may be <em>associated</em> with a
module, as follows:</p>
<ul>
<li><p>The host system may determine that an observable ordinary
compilation unit is associated with a module chosen by the host system,
except for (i) the ordinary compilation units in the predefined package
<code>java</code> and its subpackages <code>lang</code> and
<code>io</code>, which are all associated with the
<code>java.base</code> module, and (ii) any ordinary compilation unit in
an unnamed package, which is associated with a module as specified in <a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-7.html#jls-7.4.2">7.4.2</a>.</p></li>
<li><p>The host system must determine that an observable modular
compilation unit is associated with the module declared by the modular
compilation unit.</p></li>
</ul>
<blockquote>
<p>The observability of a compilation unit influences the observability
of its package (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-7.html#jls-7.4.3">7.4.3</a>),
while the association of an observable compilation unit with a module
influences the observability of that module (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-7.html#jls-7.7.6">7.7.6</a>).</p>
</blockquote>
<p>When compiling the modular and ordinary compilation units associated
with a module <em>M</em>, the host system must respect the dependencies
specified in <em>M</em>'s declaration. Specifically, the host system
must limit the ordinary compilation units that would otherwise be
observable, to only those that are <em>visible to M</em>. The ordinary
compilation units that are visible to <em>M</em> are the observable
ordinary compilation units associated with the modules that are <em>read
by M</em>. The modules read by <em>M</em> are given by the result of
<em>resolution</em>, as described in the <code>java.lang.module</code>
package specification, with <em>M</em> as the only root module. The host
system must perform resolution to determine the modules read by
<em>M</em>; it is a compile-time error if resolution fails for any of
the reasons described in the <code>java.lang.module</code> package
specification.</p>
<blockquote>
<p>The readability relation is reflexive, so <em>M</em> reads itself,
and thus all of the modular and ordinary compilation units associated
with <em>M</em> are visible to <em>M</em>.</p>
</blockquote>
<blockquote>
<p>The modules read by <em>M</em> drive the packages that are uniquely
visible to <em>M</em> (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-7.html#jls-7.4.3">7.4.3</a>),
which in turn drives both the top level packages in scope and the
meaning of package names for code in the modular and ordinary
compilation units associated with <em>M</em> (<a
href="#jls-6.3">6.3</a>, <a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-6.html#jls-6.5.3">6.5.3</a>,
<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-6.html#jls-6.5.5">6.5.5</a>).</p>
</blockquote>
<blockquote>
<p>The rules above ensure that package and type names used in
annotations in a modular compilation unit (in particular, annotations
applied to the module declaration) are interpreted as if they appeared
in an ordinary compilation unit associated with the module.</p>
</blockquote>
<p>Classes and interfaces declared in different ordinary compilation
units can refer to each other, circularly. A Java compiler must arrange
to compile all such classes and interfaces at the same time.</p>
<h3 id="jls-7.6">7.6 Top Level Class and Interface Declarations</h3>
<p>A <em>top level class or interface declaration</em> declares a top
level class (<a href="#jls-8.1">8.1</a>) or a top level interface (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-9.1">9.1</a>).</p>
<dl>
<dt><em>TopLevelClassOrInterfaceDeclaration:</em></dt>
<dd>
<em>ClassDeclaration</em>
</dd>
<dd>
<em>InterfaceDeclaration</em>
</dd>
<dd>
<code>;</code>
</dd>
</dl>
<blockquote>
<p>Extra "<code>;</code>" tokens appearing at the level of class and
interface declarations in a compilation unit have no effect on the
meaning of the compilation unit. Stray semicolons are permitted in the
Java programming language solely as a concession to C++ programmers who
are used to placing "<code>;</code>" after a class declaration. They
should not be used in new Java code.</p>
</blockquote>
<p><strong>A top level class may also be implicitly declared (<a
href="#jls-8.1.8">8.1.8</a>).</strong></p>
<p>In the absence of an access modifier, a top level class or interface
has package access: it is accessible only within ordinary compilation
units of the package in which it is declared (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-6.html#jls-6.6.1">6.6.1</a>).
A class or interface may be declared <code>public</code> to grant access
to the class or interface from code in other packages of the same
module, and potentially from code in packages of other modules.</p>
<p>It is a compile-time error if a top level class or interface
declaration contains any one of the following access modifiers:
<code>protected</code>, <code>private</code>, or
<code>static</code>.</p>
<p>It is a compile-time error if the name of a top level class or
interface appears as the name of any other top level class or interface
declared in the same package.</p>
<p>The scope and shadowing of a top level class or interface is
specified in <a href="#jls-6.3">6.3</a> and <a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-6.html#jls-6.4">6.4</a>.</p>
<p>The fully qualified name of a top level class or interface is
specified in <a href="#jls-6.7">6.7</a>.</p>
<div class="editorial">
<p>The rest of this section is unchanged.</p>
</div>
<h2 id="jls-8">Chapter 8: Classes</h2>
<h3 id="jls-8.1">8.1 Class Declarations</h3>
<p>A <em>class declaration</em> specifies a class.</p>
<p>There are three kinds of class declarations: <em>normal class
declarations</em>, <em>enum declarations</em> (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-8.9">8.9</a>),
and <em>record declarations</em> (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-8.10">8.10</a>).</p>
<dl>
<dt><em>ClassDeclaration:</em></dt>
<dd>
<em>NormalClassDeclaration</em>
</dd>
<dd>
<em>EnumDeclaration</em>
</dd>
<dd>
<em>RecordDeclaration</em>
</dd>
<dt><em>NormalClassDeclaration:</em></dt>
<dd>
{<em>ClassModifier</em>} <code>class</code> <em>TypeIdentifier</em>
[<em>TypeParameters</em>]<br />
[<em>ClassExtends</em>] [<em>ClassImplements</em>]
[<em>ClassPermits</em>] <em>ClassBody</em>
</dd>
</dl>
<p><del>A class is also implicitly declared by a class instance creation
expression (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-15.html#jls-15.9.5">15.9.5</a>)
and an enum constant that ends with a class body (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-8.9.1">8.9.1</a>).</del></p>
<p><strong>Some classes are implicitly declared by other constructs (<a
href="#jls-8.1.8">8.1.8</a>).</strong></p>
<p>The <em>TypeIdentifier</em> in a class declaration specifies the name
of the class.</p>
<p>It is a compile-time error if a class has the same simple name as any
of its enclosing classes or interfaces.</p>
<p>The scope and shadowing of a class declaration is specified in <a
href="#jls-6.3">6.3</a> and <a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-6.html#jls-6.4.1">6.4.1</a>.</p>
<h4 id="jls-8.1.8"><strong>8.1.8 Implicitly Declared
Classes</strong></h4>
<div class="inserted">
<p>Not all classes are specified by a class declaration. The following
constructs implicitly declare classes:</p>
<ul>
<li><p>a class instance creation expression that ends with a class body
(<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-15.html#jls-15.9.5">15.9.5</a>)</p></li>
<li><p>an enum constant that ends with a class body (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-8.9.1">8.9.1</a>)</p></li>
<li><p>a simple compilation unit (<a href="#jls-7.3">7.3</a>)</p></li>
</ul>
<p>In all cases, the members of any implicitly declared class, including
any implicitly declared members, are subject to the usual rules for
member declarations in a class.</p>
<blockquote>
<p>The following production from <a href="#jls-7.3">7.3</a> is shown
here for convenience:</p>
<dl>
<dt><em>SimpleCompilationUnit:</em></dt>
<dd>
{<em>ImportDeclaration</em>} {<em>ClassMemberDeclarationNoMethod</em>}
<em>MethodDeclaration</em> {<em>ClassMemberDeclaration</em>}
</dd>
<dt><em>ClassMemberDeclarationNoMethod:</em></dt>
<dd>
<em>FieldDeclaration</em>
</dd>
<dd>
<em>ClassDeclaration</em>
</dd>
<dd>
<em>InterfaceDeclaration</em>
</dd>
<dd>
<code>;</code>
</dd>
</dl>
</blockquote>
<p>The class implicitly declared by a simple compilation unit satisfies
the following properties:</p>
<ul>
<li><p>It is a top level class (<a href="#jls-7.6">7.6</a>).</p></li>
<li><p>Its name is a valid identifier (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-3.html#jls-3.8">3.8</a>)
determined by the host system.</p>
<blockquote>
<p>In simple implementations of the Java SE Platform, where compilation
units are stored in files, the name of this implicitly declared class
would typically be the name of the file containing the simple
compilation unit minus any extension (such as <code>.java</code> or
<code>.jav</code>).</p>
</blockquote></li>
<li><p>It is not <code>abstract</code> (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-8.1.1.1">8.1.1.1</a>).</p></li>
<li><p>It is <code>final</code> (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-8.1.1.2">8.1.1.2</a>).</p></li>
<li><p>It is a member of an unnamed package (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-7.html#jls-7.4.2">7.4.2</a>)
and has package access.</p></li>
<li><p>Its direct superclass is <code>Object</code> (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-8.1.4">8.1.4</a>).</p></li>
<li><p>It does not have any direct superinterfaces (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-8.1.5">8.1.5</a>).</p></li>
<li><p>The body of the class contains every class member declared in the
simple compilation unit (these are declarations of fields (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-8.3">8.3</a>),
methods (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-8.4">8.4</a>),
member classes (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-8.5">8.5</a>),
and member interfaces (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-9.html#jls-9.1.1.3">9.1.1.3</a>)).
It is not possible for a simple compilation unit to declare an instance
initializer (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-8.6">8.6</a>),
static initializer (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-8.7">8.7</a>),
or constructor (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-8.8">8.8</a>).</p></li>
<li><p>It has an implicitly declared default constructor (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-8.8.9">8.8.9</a>).</p></li>
</ul>
<p>It is a compile-time error if this class does not declare a candidate
<code>main</code> method (<a href="#jls-12.1.4">12.1.4</a>).</p>
<blockquote>
<p>Note that an unnamed package may have multiple implicitly declared
classes as members.</p>
</blockquote>
</div>
<h2 id="jls-12">Chapter 12: Execution</h2>
<p>This chapter specifies activities that occur during execution of a
program. It is organized around the life cycle of the Java Virtual
Machine and of the classes, interfaces, and objects that form a
program.</p>
<p>The Java Virtual Machine starts up by loading a specified class or
interface, then invoking <del>the</del> <strong>a</strong> method
<code>main</code> in this specified class or interface. Section <a
href="#jls-12.1">12.1</a> outlines the loading, linking, and
initialization steps involved in executing <code>main</code>, as an
introduction to the concepts in this chapter. Further sections specify
the details of loading (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-12.html#jls-12.2">12.2</a>),
linking (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-12.html#jls-12.3">12.3</a>),
and initialization (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-12.html#jls-12.4">12.4</a>).</p>
<p>The chapter continues with a specification of the procedures for
creation of new class instances (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-12.html#jls-12.5">12.5</a>);
and finalization of class instances (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-12.html#jls-12.6">12.6</a>).
It concludes by describing the unloading of classes (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-12.html#jls-12.7">12.7</a>)
and the procedure followed when a program exits (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-12.html#jls-12.8">12.8</a>).</p>
<h3 id="jls-12.1">12.1 Java Virtual Machine Startup</h3>
<p>The Java Virtual Machine starts execution by invoking <del>the</del>
<strong>a</strong> method <code>main</code> of some specified class or
interface. <strong>If this <code>main</code> method has a formal
parameter, it is passed</strong> <del>passing it</del> a single argument
which is an array of strings. <del>In the examples in this
specification, this first class is typically called
<code>Test</code>.</del></p>
<p>The precise semantics of Java Virtual Machine startup are given in
Chapter 5 of <em>The Java Virtual Machine Specification, Java SE 22
Edition</em>. Here we present an overview of the process from the
viewpoint of the Java programming language.</p>
<p>The manner in which the initial class or interface is specified to
the Java Virtual Machine is beyond the scope of this specification, but
it is typical, in host environments that use command lines, for the
fully qualified name of the <strong>initial</strong> class or interface
to be specified as a command line argument and for following command
line arguments to be used as strings to be provided as the argument to
the method <code>main</code>. <strong>If the original compilation unit
was a simple compilation unit (<a href="#jls-7.3">7.3</a>), then the
name of the file that contained the compilation unit, minus any
extension, is typically used to specify the name of the initial class or
interface.</strong></p>
<blockquote>
<p>For example, in a UNIX implementation, the command line:</p>
<pre><code>java Test reboot Bob Dot Enzo</code></pre>
<p>will typically start a Java Virtual Machine by invoking method
<code>main</code> of class <code>Test</code> (a class in an unnamed
package), passing it an <strong>argument</strong> array containing the
four strings "<code>reboot</code>", "<code>Bob</code>",
"<code>Dot</code>", and "<code>Enzo</code>".</p>
</blockquote>
<div class="inserted">
<blockquote>
<p>Whereas if the file <code>HelloWorld.java</code> contained the
following simple compilation unit:</p>
<pre><code>void main() {
    System.out.println(&quot;Hello, World!&quot;);
}</code></pre>
<p>which has been compiled, then the command line:</p>
<pre><code>java HelloWorld</code></pre>
<p>will typically start a Java Virtual Machine by invoking the
<code>main</code> method of the implicitly declared class (<a
href="#jls-8.1.8">8.1.8</a>) producing the output:</p>
<pre><code>Hello, World!</code></pre>
</blockquote>
</div>
<p>We now outline the steps the Java Virtual Machine may take to execute
<del><code>Test</code></del> <strong>the initial class or
interface</strong>, as an example of the loading, linking, and
initialization processes that are described further in later
sections.</p>
<h4 id="jls-12.1.1">12.1.1 Load the <strong>Initial</strong> Class
<strong>or Interface</strong> <del><code>Test</code></del></h4>
<p>The initial attempt to execute <del>the</del> <strong>a</strong>
method <code>main</code> of <strong>the initial</strong> class
<strong>or interface</strong> <del><code>Test</code></del> discovers
that <del>the class <code>Test</code></del> <strong>it</strong> is not
loaded - that is, that the Java Virtual Machine does not currently
contain a binary representation for this class <strong>or
interface</strong>. The Java Virtual Machine then uses a class loader to
attempt to find such a binary representation. If this process fails,
then an error is thrown. This loading process is described further in <a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-12.html#jls-12.2">12.2</a>.</p>
<h4 id="jls-12.1.2">12.1.2 Link <strong>the Initial Class or
Interface</strong> <del><code>Test</code></del>: Verify, Prepare,
(Optionally) Resolve</h4>
<p>After <strong>the class or interface</strong>
<del><code>Test</code></del> is loaded, it must be initialized before
<strong>a method</strong> <code>main</code> can be invoked. And
<del><code>Test</code></del>, like all classes and interfaces,
<strong>it</strong> must be linked before it is initialized. Linking
involves verification, preparation, and (optionally) resolution. Linking
is described further in <a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-12.html#jls-12.3">12.3</a>.</p>
<p>Verification checks that the loaded representation of <strong>the
class or interface</strong> <del><code>Test</code></del> is well-formed,
with a proper symbol table. Verification also checks that the code that
implements <strong>the class or interface</strong>
<del><code>Test</code></del> obeys the semantic requirements of the Java
programming language and the Java Virtual Machine. If a problem is
detected during verification, then an error is thrown. Verification is
described further in <a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-12.html#jls-12.3.1">12.3.1</a>.</p>
<p>Preparation involves allocation of static storage and any data
structures that are used internally by the implementation of the Java
Virtual Machine, such as method tables. Preparation is described further
in <a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-12.html#jls-12.3.2">12.3.2</a>.</p>
<p>Resolution is the process of checking symbolic references from
<strong>the class or interface</strong> <del><code>Test</code></del> to
other classes and interfaces, by loading the other classes and
interfaces that are mentioned and checking that the references are
correct.</p>
<p>The resolution step is optional at the time of initial linkage. An
implementation may resolve symbolic references from a class or interface
that is being linked very early, even to the point of resolving all
symbolic references from the classes and interfaces that are further
referenced, recursively. (This resolution may result in errors from
these further loading and linking steps.) This implementation choice
represents one extreme and is similar to the kind of "static" linkage
that has been done for many years in simple implementations of the C
language. (In these implementations, a compiled program is typically
represented as an "<code>a.out</code>" file that contains a fully-linked
version of the program, including completely resolved links to library
routines used by the program. Copies of these library routines are
included in the "<code>a.out</code>" file.)</p>
<p>An implementation may instead choose to resolve a symbolic reference
only when it is actively used; consistent use of this strategy for all
symbolic references would represent the "laziest" form of resolution. In
this case, if <strong>the class or interface</strong>
<del><code>Test</code></del> had several symbolic references to another
class, then the references might be resolved one at a time, as they are
used, or perhaps not at all, if these references were never used during
execution of the program.</p>
<p>The only requirement on when resolution is performed is that any
errors detected during resolution must be thrown at a point in the
program where some action is taken by the program that might, directly
or indirectly, require linkage to the class or interface involved in the
error. Using the "static" example implementation choice described above,
loading and linkage errors could occur before the program is executed if
they involved a class or interface mentioned in the
<strong>initial</strong> class <strong>or interface</strong>
<del><code>Test</code></del> or any of the further, recursively
referenced, classes and interfaces. In a system that implemented the
"laziest" resolution, these errors would be thrown only when an
incorrect symbolic reference is actively used.</p>
<p>The resolution process is described further in <a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-12.html#jls-12.3.3">12.3.3</a>.</p>
<h4 id="jls-12.1.3">12.1.3 Initialize <strong>the Initial Class or
Interface</strong> <del>Test</del>: Execute Initializers</h4>
<p>In our continuing example, the Java Virtual Machine is still trying
to execute <del>the</del> <strong>a</strong> method <code>main</code> of
<strong>the initial</strong> class <strong>or
interface</strong><del><code>Test</code></del>. This is permitted only
if the class has been initialized (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-12.html#jls-12.4.1">12.4.1</a>).</p>
<p>Initialization consists of execution of any class variable
initializers and static initializers of the <strong>initial</strong>
class <strong>or interface</strong> <del><code>Test</code></del>, in
textual order. But before <strong>it</strong>
<del><code>Test</code></del> can be initialized, its direct superclass
must be initialized, as well as the direct superclass of its direct
superclass, and so on, recursively. In the simplest case, <strong>the
initial class or interface</strong> <del><code>Test</code></del> has
<code>Object</code> as its implicit direct superclass; if class
<code>Object</code> has not yet been initialized, then it must be
initialized before <strong>the initial class or interface</strong>
<del><code>Test</code></del> is initialized. Class <code>Object</code>
has no superclass, so the recursion terminates here.</p>
<p>If <strong>the initial</strong> class <strong>or interface</strong>
<del><code>Test</code></del> has another class <code>Super</code> as its
superclass, then <code>Super</code> must be initialized before
<strong>the initial class or
interface</strong><del><code>Test</code></del>. This requires loading,
verifying, and preparing <code>Super</code> if this has not already been
done and, depending on the implementation, may also involve resolving
the symbolic references from <code>Super</code> and so on,
recursively.</p>
<p>Initialization may thus cause loading, linking, and initialization
errors, including such errors involving other classes and
interfaces.</p>
<p>The initialization process is described further in <a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-12.html#jls-12.4">12.4</a>.</p>
<h4 id="jls-12.1.4">12.1.4 Invoke <del><code>Test.main</code></del>
<strong>a <code>main</code> method</strong></h4>
<p>Finally, after completion of the initialization for <strong>the
initial</strong> class <strong>or interface</strong>
<del><code>Test</code></del> (during which other consequential loading,
linking, and initializing may have occurred), <del>the</del> <strong>a
<code>main</code></strong> method <del><code>main</code> of</del>
<strong> declared in or inherited by the initial class or
interface</strong> <del><code>Test</code></del> is invoked.</p>
<div class="deleted">
<p>The method <code>main</code> must be declared <code>public</code>,
<code>static</code>, and <code>void</code>. It must specify a formal
parameter (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-8.4.1">8.4.1</a>)
whose declared type is array of <code>String</code>. Therefore, either
of the following declarations is acceptable:</p>
<p><code>public static void main(String[] args)</code></p>
<p><code>public static void main(String... args)</code></p>
</div>
<div class="inserted">
<p>A method of the initial class or interface is a <em>candidate</em> if
it is named <code>main</code> and one of the following applies:</p>
<ul>
<li><p>It has a single formal parameter (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-8.4.1">8.4.1</a>)
whose declared type is an array of <code>String</code> and a
<code>void</code> result, and is with <code>public</code>,
<code>protected</code> or package access.</p></li>
<li><p>It has no formal parameters and a <code>void</code> result, and
is with <code>public</code>, <code>protected</code> or package
access.</p></li>
</ul>
<blockquote>
<p>Note that a candidate method may be either a <code>static</code> or
an instance method. A candidate method may also have a
<code>throws</code> clause (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-8.4.6">8.4.6</a>).</p>
<p>The form of a <code>main</code> method expanded significantly in Java
SE 22. Prior to that, it had to be <code>public</code>
<code>static</code> and have a single formal parameter; the only
variation possible was <code>String[]</code> versus
<code>String...</code> for the type of the single formal parameter. In
Java 22 and above, there are twelve possible forms, depending on the
access modifier, <code>static</code> modifier, and formal parameter.
This number increases to 18 if <code>String[]</code> is distinguished
from <code>String...</code> in the type of the single formal
parameter.</p>
<p>Note that it is <em>not</em> a compile-time error if the initial
class or interface counts more than one candidate method among its
members.</p>
<p>The presence of a candidate method in a class or interface may not be
immediately apparent because a <code>main</code> method may be
inherited. For example, a default method in an interface is an instance
method (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-9.html#jls-9.4">9.4</a>),
so may be a candidate when inherited by a class that implements the
interface. Development tools are encouraged to highlight when a class or
interface has a member <code>main</code> method that could serve as the
start of the program.</p>
</blockquote>
<!--
> A behavioral change was made in Java SE 22, whereby an inherited `static`
> `main` method is no longer considered a candidate method. Any existing initial
> class or interface whose only `main` method is both `static` and inherited
> will need to be refactored to continue to serve as the start of the program.
-->
<!--
If there are no candidate methods of the launch class, then the Java
Virtual Machine will emit an error.

If there are one or more candidate methods of the launch class then
selection and execution proceeds by considering, in order, the following steps:
-->
<p>A <code>main</code> method of the initial class or interface is
invoked, as if by application of the following rules:</p>
<ul>
<li><p>If there is a candidate method with a single formal parameter
then this method is invoked. If the candidate method is
<code>static</code> then it is invoked directly, passing the argument
array (<a href="#jls-12.1">12.1</a>). If the candidate method is an
instance method then it is invoked, passing the argument array, on an
instance of the initial class created by using a constructor with no
formal parameters and either <code>public</code>,
<code>protected</code>, or package access.</p></li>
<li><p>Otherwise, if there is a candidate method with no formal
parameters then this method is invoked. If the candidate method is
<code>static</code> then it is invoked directly. If the candidate method
is an instance method then it is invoked on an instance of the initial
class created by using a constructor with no formal parameters and
either <code>public</code>, <code>protected</code>, or package
access.</p></li>
</ul>
<blockquote>
<p>Note that it is not possible for a class to have both a
<code>static</code> and an instance method with the same signature (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-8.4.2">8.4.2</a>).</p>
<p>The behavior of an implementation if there is no candidate method to
invoke, or if there is no suitable constructor in the initial class when
invoking an instance candidate method, is beyond the scope of this
specification.</p>
</blockquote>
</div>
<h2 id="jls-13">Chapter 13: Binary Compatibility</h2>
<h3 id="jls-13.1">13.1 The Form of a Binary</h3>
<p>Programs must be compiled either into the <code>class</code> file
format specified by <em>The Java Virtual Machine Specification, Java SE
22 Edition</em>, or into a representation that can be mapped into that
format by a class loader written in the Java programming language.</p>
<p>A <code>class</code> file corresponding to a class or interface
declaration must have certain properties. A number of these properties
are specifically chosen to support source code transformations that
preserve binary compatibility. The required properties are:</p>
<ol type="1">
<li><p>The class or interface must be named by its <em>binary name</em>,
which must meet the following constraints:</p>
<ul>
<li><p>The binary name of a top level class or interface (<a
href="#jls-7.6">7.6</a>) is its canonical name (<a
href="#jls-6.7">6.7</a>).</p>
<div class="inserted">
<blockquote>
<p>Note that the canonical name of the top level class implicitly
declared by a simple compilation unit is determined by the host system
(<a href="#jls-8.1.8">8.1.8</a>).</p>
</blockquote>
</div></li>
<li><p>The binary name of a member class or interface (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-8.5">8.5</a>,
<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-9.html#jls-9.5">9.5</a>)
consists of the binary name of its immediately enclosing class or
interface, followed by <code>$</code>, followed by the simple name of
the member.</p></li>
<li><p>The binary name of a local class or interface (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-14.html#jls-14.3">14.3</a>)
consists of the binary name of its immediately enclosing class or
interface, followed by <code>$</code>, followed by a non-empty sequence
of digits, followed by the simple name of the local class.</p></li>
<li><p>The binary name of an anonymous class (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-15.html#jls-15.9.5">15.9.5</a>)
consists of the binary name of its immediately enclosing class or
interface, followed by <code>$</code>, followed by a non-empty sequence
of digits.</p></li>
<li><p>The binary name of a type variable declared by a generic class or
interface (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-8.1.2">8.1.2</a>,
<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-9.html#jls-9.1.2">9.1.2</a>)
is the binary name of its immediately enclosing class or interface,
followed by <code>$</code>, followed by the simple name of the type
variable.</p></li>
<li><p>The binary name of a type variable declared by a generic method
(<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-8.4.4">8.4.4</a>)
is the binary name of the class or interface declaring the method,
followed by <code>$</code>, followed by the descriptor of the method
(JVMS §4.3.3), followed by <code>$</code>, followed by the simple name
of the type variable.</p></li>
<li><p>The binary name of a type variable declared by a generic
constructor (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-8.8.4">8.8.4</a>)
is the binary name of the class declaring the constructor, followed by
<code>$</code>, followed by the descriptor of the constructor (JVMS
§4.3.3), followed by <code>$</code>, followed by the simple name of the
type variable.</p></li>
</ul></li>
<li><p>A reference to another class or interface must be symbolic, using
the binary name of the class or interface.</p></li>
<li><p>A reference to a field that is a constant variable (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-4.html#jls-4.12.4">4.12.4</a>)
must be resolved at compile time to the value <em>V</em> denoted by the
constant variable's initializer.</p>
<p>If such a field is <code>static</code>, then no reference to the
field should be present in the code in a binary file, including the
class or interface which declared the field. Such a field must always
appear to have been initialized (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-12.html#jls-12.4.2">12.4.2</a>);
the default initial value for the field (if different than <em>V</em>)
must never be observed.</p>
<p>If such a field is non-<code>static</code>, then no reference to the
field should be present in the code in a binary file, except in the
class containing the field. (It will be a class rather than an
interface, since an interface has only <code>static</code> fields.) The
class should have code to set the field's value to <em>V</em> during
instance creation (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-12.html#jls-12.5">12.5</a>).</p></li>
<li><p>Given a legal expression denoting a field access in a class
<em>C</em>, referencing a field named <em>f</em> that is not a constant
variable and is declared in a (possibly distinct) class or interface
<em>D</em>, we define the <em>qualifying class or interface of the field
reference</em> as follows:</p>
<ul>
<li><p>If the expression is referenced by a simple name, then if
<em>f</em> is a member of the current class or interface, <em>C</em>,
then let <em>Q</em> be <em>C</em>. Otherwise, let <em>Q</em> be the
innermost lexically enclosing class or interface declaration of which
<em>f</em> is a member. In either case, <em>Q</em> is the qualifying
class or interface of the reference.</p></li>
<li><p>If the reference is of the form
<em>TypeName</em><code>.</code><em>f</em>, where <em>TypeName</em>
denotes a class or interface, then the class or interface denoted by
<em>TypeName</em> is the qualifying class or interface of the
reference.</p></li>
<li><p>If the expression is of the form
<em>ExpressionName</em><code>.</code><em>f</em> or
<em>Primary</em><code>.</code><em>f</em>, then:</p>
<ul>
<li><p>If the compile-time type of <em>ExpressionName</em> or
<em>Primary</em> is an intersection type <em>V<sub>1</sub></em>
<code>&amp;</code> ... <code>&amp;</code> <em>V<sub>n</sub></em> (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-4.html#jls-4.9">4.9</a>),
then the qualifying class or interface of the reference is the erasure
(<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-4.html#jls-4.6">4.6</a>)
of <em>V<sub>1</sub></em>.</p></li>
<li><p>Otherwise, the erasure of the compile-time type of
<em>ExpressionName</em> or <em>Primary</em> is the qualifying class or
interface of the reference.</p></li>
</ul></li>
<li><p>If the expression is of the form <code>super.</code><em>f</em>,
then the superclass of <em>C</em> is the qualifying class or interface
of the reference.</p></li>
<li><p>If the expression is of the form
<em>TypeName</em><code>.super.</code><em>f</em>, then the superclass of
the class denoted by <em>TypeName</em> is the qualifying class or
interface of the reference.</p></li>
</ul>
<p>The reference to <em>f</em> must be compiled into a symbolic
reference to the qualifying class or interface of the reference, plus
the simple name of the field, <em>f</em>.</p>
<p>The reference must also include a symbolic reference to the erasure
of the declared type of the field, so that the verifier can check that
the type is as expected.</p></li>
<li><p>Given a method invocation expression or a method reference
expression in a class or interface <em>C</em>, referencing a method
named <em>m</em> declared (or implicitly declared (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-9.html#jls-9.2">9.2</a>))
in a (possibly distinct) class or interface <em>D</em>, we define the
<em>qualifying class or interface of the method invocation</em> as
follows:</p>
<ul>
<li><p>If <em>D</em> is <code>Object</code> then the qualifying class or
interface of the method invocation is <code>Object</code>.</p></li>
<li><p>Otherwise:</p>
<ul>
<li><p>If the method is referenced by a simple name, then if <em>m</em>
is a member of the current class or interface <em>C</em>, let <em>Q</em>
be <em>C</em>; otherwise, let <em>Q</em> be the innermost lexically
enclosing class or interface declaration of which <em>m</em> is a
member. In either case, <em>Q</em> is the qualifying class or interface
of the method invocation.</p></li>
<li><p>If the expression is of the form
<em>TypeName</em><code>.</code><em>m</em> or
<em>ReferenceType</em><code>::</code><em>m</em>, then the class or
interface denoted by <em>TypeName</em>, or the erasure of
<em>ReferenceType</em>, is the qualifying class or interface of the
method invocation.</p></li>
<li><p>If the expression is of the form
<em>ExpressionName</em><code>.</code><em>m</em> or
<em>Primary</em><code>.</code><em>m</em> or
<em>ExpressionName</em><code>::</code><em>m</em> or
<em>Primary</em><code>::</code><em>m</em>, then:</p>
<ul>
<li><p>If the compile-time type of <em>ExpressionName</em> or
<em>Primary</em> is an intersection type <em>V<sub>1</sub></em>
<code>&amp;</code> ... <code>&amp;</code> <em>V<sub>n</sub></em>, then
the qualifying class or interface of the method invocation is the
erasure of <em>V<sub>1</sub></em>.</p></li>
<li><p>Otherwise, the erasure of the compile-time type of
<em>ExpressionName</em> or <em>Primary</em> is the qualifying class or
interface of the method invocation.</p></li>
</ul></li>
<li><p>If the expression is of the form <code>super.</code><em>m</em> or
<code>super::</code><em>m</em>, then the superclass of <em>C</em> is the
qualifying class or interface of the method invocation.</p></li>
<li><p>If the expression is of the form
<em>TypeName</em><code>.super.</code><em>m</em> or
<em>TypeName</em><code>.super::</code><em>m</em>, then if
<em>TypeName</em> denotes a class <em>X</em>, the superclass of
<em>X</em> is the qualifying class or interface of the method
invocation; if <em>TypeName</em> denotes an interface <em>X</em>,
<em>X</em> is the qualifying class or interface of the method
invocation.</p></li>
</ul></li>
</ul>
<p>A reference to a method must be resolved at compile time to a
symbolic reference to the qualifying class or interface of the method
invocation, plus the erasure of the declared signature (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-8.4.2">8.4.2</a>)
of the method. The signature of a method must include all of the
following as determined by <a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-15.html#jls-15.12.3">15.12.3</a>:</p>
<ul>
<li><p>The simple name of the method</p></li>
<li><p>The number of parameters to the method</p></li>
<li><p>A symbolic reference to the type of each parameter</p></li>
</ul>
<p>A reference to a method must also include either a symbolic reference
to the erasure of the return type of the denoted method or an indication
that the denoted method is declared <code>void</code> and does not
return a value.</p></li>
<li><p>Given a class instance creation expression (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-15.html#jls-15.9">15.9</a>)
or an explicit constructor invocation statement (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-8.8.7.1">8.8.7.1</a>)
or a method reference expression of the form <em>ClassType
<code>::</code> <code>new</code></em> (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-15.html#jls-15.13">15.13</a>)
in a class or interface <em>C</em>, referencing a constructor <em>m</em>
declared in a (possibly distinct) class or interface <em>D</em>, we
define the <em>qualifying class of the constructor invocation</em> as
follows:</p>
<ul>
<li><p>If the expression is of the form <code>new</code>
<em>D</em><code>(...)</code> or <em>ExpressionName</em><code>.new</code>
<em>D</em><code>(...)</code> or <em>Primary</em><code>.new</code>
<em>D</em><code>(...)</code> or <em>D</em> <code>::</code>
<code>new</code>, then the qualifying class of the constructor
invocation is <em>D</em>.</p></li>
<li><p>If the expression is of the form <code>new</code>
<em>D</em><code>(...){...}</code> or
<em>ExpressionName</em><code>.new</code>
<em>D</em><code>(...){...}</code> or <em>Primary</em><code>.new</code>
<em>D</em><code>(...){...}</code>, then the qualifying class of the
constructor invocation is the anonymous class declared by the
expression.</p></li>
<li><p>If the expression is of the form <code>super(...)</code> or
<em>ExpressionName</em><code>.super(...)</code> or
<em>Primary</em><code>.super(...)</code>, then the qualifying class of
the constructor invocation is the direct superclass of
<em>C</em>.</p></li>
<li><p>If the expression is of the form <code>this(...)</code>, then the
qualifying class of the constructor invocation is <em>C</em>.</p></li>
</ul>
<p>A reference to a constructor must be resolved at compile time to a
symbolic reference to the qualifying class of the constructor
invocation, plus the declared signature of the constructor (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-8.8.2">8.8.2</a>).
The signature of a constructor must include both:</p>
<ul>
<li><p>The number of parameters of the constructor</p></li>
<li><p>A symbolic reference to the type of each formal
parameter</p></li>
</ul></li>
</ol>
<p>A binary representation for a class or interface must also contain
all of the following:</p>
<ol type="1">
<li><p>If it is a class and is not <code>Object</code>, then a symbolic
reference to the direct superclass of this class.</p></li>
<li><p>A symbolic reference to each direct superinterface, if
any.</p></li>
<li><p>A specification of each field declared in the class or interface,
given as the simple name of the field and a symbolic reference to the
erasure of the type of the field.</p></li>
<li><p>If it is a class, then the erased signature of each constructor,
as described above.</p></li>
<li><p>For each method declared in the class or interface (excluding,
for an interface, its implicitly declared methods (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-9.html#jls-9.2">9.2</a>)),
its erased signature and return type, as described above.</p></li>
<li><p>The code needed to implement the class or interface:</p>
<ul>
<li><p>For an interface, code for the field initializers and the
implementation of each method with a block body (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-9.html#jls-9.4.3">9.4.3</a>).</p></li>
<li><p>For a class, code for the field initializers, the instance and
static initializers, the implementation of each method with a block body
(<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-8.4.7">8.4.7</a>),
and the implementation of each constructor.</p></li>
</ul></li>
<li><p>Every class or interface must contain sufficient information to
recover its canonical name (<a href="#jls-6.7">6.7</a>).</p></li>
<li><p>Every member class or interface must have sufficient information
to recover its source-level access modifier (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-6.html#jls-6.6">6.6</a>).</p></li>
<li><p>Every nested class or interface must have a symbolic reference to
its immediately enclosing class or interface (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-8.1.3">8.1.3</a>).</p></li>
<li><p>Every class or interface must contain symbolic references to all
of its member classes and interfaces (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-8.5">8.5</a>,
<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-9.html#jls-9.5">9.5</a>),
and to all other nested classes and interfaces declared within its
body.</p></li>
<li><p>A construct emitted by a Java compiler must be marked as
<em>synthetic</em> if it does not correspond to a construct declared
explicitly or implicitly in source code, unless the emitted construct is
a class initialization method (JVMS §2.9).</p></li>
<li><p>A construct emitted by a Java compiler must be marked as
<em>mandated</em> if it corresponds to a formal parameter declared
implicitly in source code (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-8.8.1">8.8.1</a>,
<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-8.8.9">8.8.9</a>,
<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-8.9.3">8.9.3</a>,
<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-15.html#jls-15.9.5.1">15.9.5.1</a>).</p></li>
</ol>
<blockquote>
<p>The following formal parameters are declared implicitly in source
code:</p>
</blockquote>
<blockquote>
<ul>
<li><p>The first formal parameter of a constructor of a
non-<code>private</code> inner member class (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-8.8.1">8.8.1</a>,
<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-8.8.9">8.8.9</a>).</p></li>
<li><p>The first formal parameter of an anonymous constructor of an
anonymous class whose superclass is an inner class (not in a static
context) (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-15.html#jls-15.9.5.1">15.9.5.1</a>).</p></li>
<li><p>The formal parameter <code>name</code> of the
<code>valueOf</code> method which is implicitly declared in an enum
class (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-8.9.3">8.9.3</a>).</p></li>
<li><p>The formal parameters of a compact constructor of a record class
(<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-8.10.4">8.10.4</a>).</p></li>
</ul>
</blockquote>
<blockquote>
<p>For reference, the following constructs are declared implicitly in
source code, but are not marked as mandated because only formal
parameters and modules can be so marked in a <code>class</code> file
(JVMS §4.7.24, JVMS §4.7.25):</p>
</blockquote>
<blockquote>
<ul>
<li><p>Default constructors of normal and enum classes (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-8.8.9">8.8.9</a>,
<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-8.9.2">8.9.2</a>)</p></li>
<li><p>Canonical constructors of record classes (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-8.10.4">8.10.4</a>)</p></li>
<li><p>Anonymous constructors (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-15.html#jls-15.9.5.1">15.9.5.1</a>)</p></li>
<li><p>The <code>values</code> and <code>valueOf</code> methods of enum
classes (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-8.9.3">8.9.3</a>)</p></li>
<li><p>Certain <code>public</code> fields of enum classes (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-8.9.3">8.9.3</a>)</p></li>
<li><p>Certain <code>private</code> fields and <code>public</code>
methods of record classes (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-8.html#jls-8.10.3">8.10.3</a>)</p></li>
<li><p>Certain <code>public</code> methods of interfaces (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-9.html#jls-9.2">9.2</a>)</p></li>
<li><p>Container annotations (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-9.html#jls-9.7.5">9.7.5</a>)</p></li>
<li><p><strong>Classes implicitly declared by a simple compilation unit
(<a href="#jls-8.1.8">8.1.8</a>).</strong></p></li>
</ul>
</blockquote>
<p>A <code>class</code> file corresponding to a module declaration must
have the properties of a <code>class</code> file for a class whose
binary name is <code>module-info</code> and which has no superclass, no
superinterfaces, no fields, and no methods. In addition, the binary
representation of the module must contain all of the following:</p>
<ul>
<li><p>A specification of the name of the module, given as a symbolic
reference to the name indicated after <code>module</code>. Also, the
specification must include whether the module is normal or open (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-7.html#jls-7.7">7.7</a>).</p></li>
<li><p>A specification of each dependence denoted by a
<code>requires</code> directive, given as a symbolic reference to the
name of the module indicated by the directive (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-7.html#jls-7.7.1">7.7.1</a>).
Also, the specification must include whether the dependence is
<code>transitive</code> and whether the dependence is
<code>static</code>.</p></li>
<li><p>A specification of each package denoted by an
<code>exports</code> or <code>opens</code> directive, given as a
symbolic reference to the name of the package indicated by the directive
(<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-7.html#jls-7.7.2">7.7.2</a>).
Also, if the directive was qualified, the specification must give
symbolic references to the names of the modules indicated by the
directive's <code>to</code> clause.</p></li>
<li><p>A specification of each service denoted by a <code>uses</code>
directive, given as a symbolic reference to the name of the class or
interface indicated by the directive (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-7.html#jls-7.7.3">7.7.3</a>).</p></li>
<li><p>A specification of the service providers denoted by a
<code>provides</code> directive, given as symbolic references to the
names of the classes and interfaces indicated by the directive's
<code>with</code> clause (<a
href="https://docs.oracle.com/javase/specs/jls/se21/html/jls-7.html#jls-7.7.4">7.7.4</a>).
Also, the specification must give a symbolic reference to the name of
the class or interface indicated as the service by the
directive.</p></li>
</ul>
<p>The following sections discuss changes that may be made to class and
interface declarations without breaking compatibility with pre-existing
binaries. Under the translation requirements given above, the Java
Virtual Machine and its <code>class</code> file format support these
changes. Any other valid binary format, such as a compressed or
encrypted representation that is mapped back into <code>class</code>
files by a class loader under the above requirements, will necessarily
support these changes as well.</p>
</main><footer class="legal-footer"><hr/><a href="../legal/copyright.html">Copyright</a> &copy; 1993, 2024, Oracle and/or its affiliates, 500 Oracle Parkway, Redwood Shores, CA 94065 USA.<br>All rights reserved. Use is subject to <a href="https://www.oracle.com/java/javase/terms/license/java22speclicense.html">license terms</a> and the <a href="https://www.oracle.com/technetwork/java/redist-137594.html">documentation redistribution policy</a>. <!-- Version 22.0.2+9-70 --></footer>
</body>
</html>