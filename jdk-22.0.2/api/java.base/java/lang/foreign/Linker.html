<!DOCTYPE HTML>
<html lang="en">
<head>
<!-- Generated by javadoc (22) -->
<title>Linker (Java SE 22 &amp; JDK 22)</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="description" content="declaration: module: java.base, package: java.lang.foreign, interface: Linker">
<meta name="generator" content="javadoc/ClassWriter">
<meta name="keywords" content="java.lang.foreign.Linker interface">
<meta name="keywords" content="nativeLinker()">
<meta name="keywords" content="downcallHandle()">
<meta name="keywords" content="upcallStub()">
<meta name="keywords" content="defaultLookup()">
<meta name="keywords" content="canonicalLayouts()">
<link rel="stylesheet" type="text/css" href="../../../../resource-files/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../resource-files/stylesheet.css" title="Style">
<script type="text/javascript" src="../../../../script-files/script.js"></script>
<script type="text/javascript" src="../../../../script-files/jquery-3.6.1.min.js"></script>
<script type="text/javascript" src="../../../../script-files/jquery-ui.min.js"></script>
</head>
<body class="class-declaration-page">
<script type="text/javascript">var pathtoroot = "../../../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<header role="banner">
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="top-nav" id="navbar-top"><button id="navbar-toggle-button" aria-controls="navbar-top" aria-expanded="false" aria-label="Toggle navigation links"><span class="nav-bar-toggle-icon">&nbsp;</span><span class="nav-bar-toggle-icon">&nbsp;</span><span class="nav-bar-toggle-icon">&nbsp;</span></button>
<div class="skip-nav"><a href="#skip-navbar-top" title="Skip navigation links">Skip navigation links</a></div>
<div class="about-language"><div style="margin-top: 14px;"><strong>Java SE 22 &amp; JDK 22</strong> </div></div>
<ul id="navbar-top-firstrow" class="nav-list" title="Navigation">
<li><a href="../../../../index.html">Overview</a></li>
<li><a href="../../../module-summary.html">Module</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="class-use/Linker.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../preview-list.html">Preview</a></li>
<li><a href="../../../../new-list.html">New</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-files/index-1.html">Index</a></li>
<li><a href="../../../../help-doc.html#class">Help</a></li>
</ul>
<ul class="sub-nav-list-small">
<li>
<p>Summary:</p>
<ul>
<li><a href="#nested-class-summary">Nested</a></li>
<li>Field</li>
<li>Constr</li>
<li><a href="#method-summary">Method</a></li>
</ul>
</li>
<li>
<p>Detail:</p>
<ul>
<li>Field</li>
<li>Constr</li>
<li><a href="#method-detail">Method</a></li>
</ul>
</li>
</ul>
</div>
<div class="sub-nav">
<div id="navbar-sub-list">
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li><a href="#nested-class-summary">Nested</a>&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method-summary">Method</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method-detail">Method</a></li>
</ul>
</div>
<div class="nav-list-search"><a href="../../../../search.html">SEARCH</a>
<input type="text" id="search-input" disabled placeholder="Search">
<input type="reset" id="reset-button" disabled value="reset">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<span class="skip-nav" id="skip-navbar-top"></span></nav>
</header>
<main role="main">
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="sub-title"><span class="module-label-in-type">Module</span>&nbsp;<a href="../../../module-summary.html">java.base</a></div>
<div class="sub-title"><span class="package-label-in-type">Package</span>&nbsp;<a href="package-summary.html">java.lang.foreign</a></div>
<h1 title="Interface Linker" class="title">Interface Linker</h1>
</div>
<section class="class-description" id="class-description">
<div class="horizontal-scroll">
<hr>
<div class="type-signature"><span class="modifiers">public sealed interface </span><span class="element-name type-name-label">Linker</span></div>
<div class="block">A linker provides access to foreign functions from Java code, and access to Java code
 from foreign functions.
 <p>
 Foreign functions typically reside in libraries that can be loaded on demand. Each
 library conforms to a specific ABI (Application Binary Interface). An ABI is a set of
 calling conventions and data types associated with the compiler, OS, and processor where
 the library was built. For example, a C compiler on Linux/x64 usually builds libraries
 that conform to the SystemV ABI.
 <p>
 A linker has detailed knowledge of the calling conventions and data types used by a
 specific ABI. For any library that conforms to that ABI, the linker can mediate
 between Java code running in the JVM and foreign functions in the library. In
 particular:
 <ul>
 <li>A linker allows Java code to link against foreign functions, via
 <a href="#downcallHandle(java.lang.foreign.MemorySegment,java.lang.foreign.FunctionDescriptor,java.lang.foreign.Linker.Option...)">downcall method handles</a><sup><a href="#restricted-downcallHandle(java.lang.foreign.MemorySegment,java.lang.foreign.FunctionDescriptor,java.lang.foreign.Linker.Option...)">RESTRICTED</a></sup>;
 and</li>
 <li>A linker allows foreign functions to call Java method handles, via the generation
 of <a href="#upcallStub(java.lang.invoke.MethodHandle,java.lang.foreign.FunctionDescriptor,java.lang.foreign.Arena,java.lang.foreign.Linker.Option...)">upcall stubs</a><sup><a href="#restricted-upcallStub(java.lang.invoke.MethodHandle,java.lang.foreign.FunctionDescriptor,java.lang.foreign.Arena,java.lang.foreign.Linker.Option...)">RESTRICTED</a></sup>.</li>
 </ul>
 A linker provides a way to look up the <em>canonical layouts</em> associated with the
 data types used by the ABI. For example, a linker implementing the C ABI might choose
 to provide a canonical layout for the C <code>size_t</code> type. On 64-bit platforms,
 this canonical layout might be equal to <a href="ValueLayout.html#JAVA_LONG"><code>ValueLayout.JAVA_LONG</code></a>. The canonical
 layouts supported by a linker are exposed via the <a href="#canonicalLayouts()"><code>canonicalLayouts()</code></a> method,
 which returns a map from type names to canonical layouts.
 <p>
 In addition, a linker provides a way to look up foreign functions in libraries that
 conform to the ABI. Each linker chooses a set of libraries that are commonly used on
 the OS and processor combination associated with the ABI. For example, a linker for
 Linux/x64 might choose two libraries: <code>libc</code> and <code>libm</code>. The functions in
 these libraries are exposed via a <a href="#defaultLookup()">symbol lookup</a>.

 <h2 id="native-linker">Calling native functions</h2>

 The <a href="#nativeLinker()">native linker</a> can be used to link against functions
 defined in C libraries (native functions). Suppose we wish to downcall from Java to
 the <code>strlen</code> function defined in the standard C library:
 
<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="../../../../resource-files/copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-c">size_t strlen(const char *s);
</code></pre>
</div>

 A downcall method handle that exposes <code>strlen</code> is obtained, using the native
 linker, as follows:

 
<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="../../../../resource-files/copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-java">Linker linker = Linker.nativeLinker();
MethodHandle strlen = linker.downcallHandle(
    linker.defaultLookup().find("strlen").orElseThrow(),
    FunctionDescriptor.of(JAVA_LONG, ADDRESS)
);
</code></pre>
</div>


 Note how the native linker also provides access, via its <a href="#defaultLookup()">default lookup</a>,
 to the native functions defined by the C libraries loaded with the Java runtime.
 Above, the default lookup is used to search the address of the <code>strlen</code> native
 function. That address is then passed, along with a <em>platform-dependent description</em>
 of the signature of the function expressed as a <a href="FunctionDescriptor.html" title="interface in java.lang.foreign"><code>FunctionDescriptor</code></a> (more on
 that below) to the native linker's <a href="#downcallHandle(java.lang.foreign.MemorySegment,java.lang.foreign.FunctionDescriptor,java.lang.foreign.Linker.Option...)"><code>downcallHandle(MemorySegment, FunctionDescriptor, Option...)</code></a><sup><a href="#restricted-downcallHandle(java.lang.foreign.MemorySegment,java.lang.foreign.FunctionDescriptor,java.lang.foreign.Linker.Option...)">RESTRICTED</a></sup>
 method. The obtained downcall method handle is then invoked as follows:

 
<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="../../../../resource-files/copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-java"> try (Arena arena = Arena.ofConfined()) {
     MemorySegment str = arena.allocateFrom("Hello");
     long len = (long) strlen.invokeExact(str);  // 5
 }
</code></pre>
</div>

 <h3 id="describing-c-sigs">Describing C signatures</h3>

 When interacting with the native linker, clients must provide a platform-dependent
 description of the signature of the C function they wish to link against. This
 description, a <a href="FunctionDescriptor.html" title="interface in java.lang.foreign"><code>function descriptor</code></a>, defines the layouts
 associated with the parameter types and return type (if any) of the C function.
 <p>
 Scalar C types such as <code>bool</code>, <code>int</code> are modeled as
 <a href="ValueLayout.html" title="interface in java.lang.foreign">value layouts</a> of a suitable carrier. The
 <a href="#canonicalLayouts()">mapping</a> between a scalar type and its corresponding
 canonical layout is dependent on the ABI implemented by the native linker (see below).
 <p>
 Composite types are modeled as <a href="GroupLayout.html" title="interface in java.lang.foreign">group layouts</a>. More
 specifically, a C <code>struct</code> type maps to a <a href="StructLayout.html" title="interface in java.lang.foreign">struct layout</a>,
 whereas a C <code>union</code> type maps to a <a href="UnionLayout.html" title="interface in java.lang.foreign"><code>union layout</code></a>. When defining
 a struct or union layout, clients must pay attention to the size and alignment constraint
 of the corresponding composite type definition in C. For instance, padding between two
 struct fields must be modeled explicitly, by adding an adequately sized
 <a href="PaddingLayout.html" title="interface in java.lang.foreign">padding layout</a> member to the resulting struct layout.
 <p>
 Finally, pointer types such as <code>int**</code> and <code>int(*)(size_t*, size_t*)</code>
 are modeled as <a href="AddressLayout.html" title="interface in java.lang.foreign">address layouts</a>. When the spatial bounds of
 the pointer type are known statically, the address layout can be associated with a
 <a href="AddressLayout.html#targetLayout()">target layout</a>. For instance, a pointer that
 is known to point to a C <code>int[2]</code> array can be modeled as an address layout
 whose target layout is a sequence layout whose element count is 2, and whose
 element type is <a href="ValueLayout.html#JAVA_INT"><code>ValueLayout.JAVA_INT</code></a>.
 <p>
 All native linker implementations are guaranteed to provide canonical layouts for the
 following set of types:
 <ul>
     <li><code>bool</code></li>
     <li><code>char</code></li>
     <li><code>short</code></li>
     <li><code>int</code></li>
     <li><code>long</code></li>
     <li><code>long long</code></li>
     <li><code>float</code></li>
     <li><code>double</code></li>
     <li><code>size_t</code></li>
     <li><code>wchar_t</code></li>
     <li><code>void*</code></li>
 </ul>
 As noted above, the specific canonical layout associated with each type can vary,
 depending on the data model supported by a given ABI. For instance, the C type
 <code>long</code> maps to the layout constant <a href="ValueLayout.html#JAVA_LONG"><code>ValueLayout.JAVA_LONG</code></a> on Linux/x64,
 but maps to the layout constant <a href="ValueLayout.html#JAVA_INT"><code>ValueLayout.JAVA_INT</code></a> on Windows/x64.
 Similarly, the C type <code>size_t</code> maps to the layout constant
 <a href="ValueLayout.html#JAVA_LONG"><code>ValueLayout.JAVA_LONG</code></a> on 64-bit platforms, but maps to the layout constant
 <a href="ValueLayout.html#JAVA_INT"><code>ValueLayout.JAVA_INT</code></a> on 32-bit platforms.
 <p>
 A native linker typically does not provide canonical layouts for C's unsigned integral
 types. Instead, they are modeled using the canonical layouts associated with their
 corresponding signed integral types. For instance, the C type <code>unsigned long</code>
 maps to the layout constant <a href="ValueLayout.html#JAVA_LONG"><code>ValueLayout.JAVA_LONG</code></a> on Linux/x64, but maps to
 the layout constant <a href="ValueLayout.html#JAVA_INT"><code>ValueLayout.JAVA_INT</code></a> on Windows/x64.
 <p>
 The following table shows some examples of how C types are modeled in Linux/x64
 according to the "System V Application Binary Interface"
 (all the examples provided here will assume these platform-dependent mappings):

 <blockquote><table class="plain">
 <caption style="display:none">Mapping C types</caption>
 <thead>
 <tr>
     <th scope="col">C type</th>
     <th scope="col">Layout</th>
     <th scope="col">Java type</th>
 </tr>
 </thead>
 <tbody>
 <tr><th scope="row" style="font-weight:normal"><code>bool</code></th>
     <td style="text-align:center;"><a href="ValueLayout.html#JAVA_BOOLEAN"><code>ValueLayout.JAVA_BOOLEAN</code></a></td>
     <td style="text-align:center;"><code>boolean</code></td>
 <tr><th scope="row" style="font-weight:normal"><code>char</code> <br> <code>unsigned char</code></th>
     <td style="text-align:center;"><a href="ValueLayout.html#JAVA_BYTE"><code>ValueLayout.JAVA_BYTE</code></a></td>
     <td style="text-align:center;"><code>byte</code></td>
 <tr><th scope="row" style="font-weight:normal"><code>short</code> <br> <code>unsigned short</code></th>
     <td style="text-align:center;"><a href="ValueLayout.html#JAVA_SHORT"><code>ValueLayout.JAVA_SHORT</code></a></td>
     <td style="text-align:center;"><code>short</code></td>
 <tr><th scope="row" style="font-weight:normal"><code>int</code> <br> <code>unsigned int</code></th>
     <td style="text-align:center;"><a href="ValueLayout.html#JAVA_INT"><code>ValueLayout.JAVA_INT</code></a></td>
     <td style="text-align:center;"><code>int</code></td>
 <tr><th scope="row" style="font-weight:normal"><code>long</code> <br> <code>unsigned long</code></th>
     <td style="text-align:center;"><a href="ValueLayout.html#JAVA_LONG"><code>ValueLayout.JAVA_LONG</code></a></td>
     <td style="text-align:center;"><code>long</code></td>
 <tr><th scope="row" style="font-weight:normal"><code>long long</code> <br> <code>unsigned long long</code></th>
     <td style="text-align:center;"><a href="ValueLayout.html#JAVA_LONG"><code>ValueLayout.JAVA_LONG</code></a></td>
     <td style="text-align:center;"><code>long</code></td>
 <tr><th scope="row" style="font-weight:normal"><code>float</code></th>
     <td style="text-align:center;"><a href="ValueLayout.html#JAVA_FLOAT"><code>ValueLayout.JAVA_FLOAT</code></a></td>
     <td style="text-align:center;"><code>float</code></td>
 <tr><th scope="row" style="font-weight:normal"><code>double</code></th>
     <td style="text-align:center;"><a href="ValueLayout.html#JAVA_DOUBLE"><code>ValueLayout.JAVA_DOUBLE</code></a></td>
     <td style="text-align:center;"><code>double</code></td>
 <tr><th scope="row" style="font-weight:normal"><code>size_t</code></th>
     <td style="text-align:center;"><a href="ValueLayout.html#JAVA_LONG"><code>ValueLayout.JAVA_LONG</code></a></td>
     <td style="text-align:center;"><code>long</code></td>
 <tr><th scope="row" style="font-weight:normal"><code>char*</code>, <code>int**</code>, <code>struct Point*</code></th>
     <td style="text-align:center;"><a href="ValueLayout.html#ADDRESS"><code>ValueLayout.ADDRESS</code></a></td>
     <td style="text-align:center;"><a href="MemorySegment.html" title="interface in java.lang.foreign"><code>MemorySegment</code></a></td>
 <tr><th scope="row" style="font-weight:normal"><code>int (*ptr)[10]</code></th>
     <td style="text-align:left;">
 <pre>
 ValueLayout.ADDRESS.withTargetLayout(
     MemoryLayout.sequenceLayout(10,
         ValueLayout.JAVA_INT)
 );
 </pre>
     <td style="text-align:center;"><a href="MemorySegment.html" title="interface in java.lang.foreign"><code>MemorySegment</code></a></td>
 <tr><th scope="row" style="font-weight:normal"><code>struct Point { int x; long y; };</code></th>
     <td style="text-align:left;">
 <pre>
 MemoryLayout.structLayout(
     ValueLayout.JAVA_INT.withName("x"),
     MemoryLayout.paddingLayout(32),
     ValueLayout.JAVA_LONG.withName("y")
 );
 </pre>
     </td>
     <td style="text-align:center;"><a href="MemorySegment.html" title="interface in java.lang.foreign"><code>MemorySegment</code></a></td>
 <tr><th scope="row" style="font-weight:normal"><code>union Choice { float a; int b; }</code></th>
     <td style="text-align:left;">
 <pre>
 MemoryLayout.unionLayout(
     ValueLayout.JAVA_FLOAT.withName("a"),
     ValueLayout.JAVA_INT.withName("b")
 );
 </pre>
     </td>
     <td style="text-align:center;"><a href="MemorySegment.html" title="interface in java.lang.foreign"><code>MemorySegment</code></a></td>
 </tbody>
 </table></blockquote>
 <p>
 All native linker implementations support a well-defined subset of layouts. More formally,
 a layout <code>L</code> is supported by a native linker <code>NL</code> if:
 <ul>
 <li><code>L</code> is a value layout <code>V</code> and <code>V.withoutName()</code> is a canonical layout</li>
 <li><code>L</code> is a sequence layout <code>S</code> and all the following conditions hold:
 <ol>
 <li>the alignment constraint of <code>S</code> is set to its
     <a href="MemoryLayout.html#layout-align">natural alignment</a>, and</li>
 <li><code>S.elementLayout()</code> is a layout supported by <code>NL</code>.</li>
 </ol>
 </li>
 <li><code>L</code> is a group layout <code>G</code> and all the following conditions hold:
 <ol>
 <li>the alignment constraint of <code>G</code> is set to its
     <a href="MemoryLayout.html#layout-align">natural alignment</a>;</li>
 <li>the size of <code>G</code> is a multiple of its alignment constraint;</li>
 <li>each member layout in <code>G.memberLayouts()</code> is either a padding layout or
     a layout supported by <code>NL</code>, and</li>
 <li><code>G</code> does not contain padding other than what is strictly required to align
      its non-padding layout elements, or to satisfy (2).</li>
 </ol>
 </li>
 </ul>

 Linker implementations may optionally support additional layouts, such as
 <em>packed</em> struct layouts. A packed struct is a struct in which there is
 at least one member layout <code>L</code> that has an alignment constraint less strict
 than its natural alignment. This allows to avoid padding between member layouts,
 as well as avoiding padding at the end of the struct layout. For example:

 
<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="../../../../resource-files/copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-java">// No padding between the 2 element layouts:
MemoryLayout noFieldPadding = MemoryLayout.structLayout(
        ValueLayout.JAVA_INT,
        ValueLayout.JAVA_DOUBLE.withByteAlignment(4));

// No padding at the end of the struct:
MemoryLayout noTrailingPadding = MemoryLayout.structLayout(
        ValueLayout.JAVA_DOUBLE.withByteAlignment(4),
        ValueLayout.JAVA_INT);
</code></pre>
</div>

 <p>
 A native linker only supports function descriptors whose argument/return layouts are
 layouts supported by that linker and are not sequence layouts.

 <h3 id="function-pointers">Function pointers</h3>

 Sometimes, it is useful to pass Java code as a function pointer to some native
 function; this is achieved by using an
 <a href="#upcallStub(java.lang.invoke.MethodHandle,java.lang.foreign.FunctionDescriptor,java.lang.foreign.Arena,java.lang.foreign.Linker.Option...)">upcall stub</a><sup><a href="#restricted-upcallStub(java.lang.invoke.MethodHandle,java.lang.foreign.FunctionDescriptor,java.lang.foreign.Arena,java.lang.foreign.Linker.Option...)">RESTRICTED</a></sup>.
 To demonstrate this, let's consider the following function from the C standard library:

 
<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="../../../../resource-files/copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-c">void qsort(void *base, size_t nmemb, size_t size,
           int (*compar)(const void *, const void *));
</code></pre>
</div>


 The <code>qsort</code> function can be used to sort the contents of an array, using a
 custom comparator function which is passed as a function pointer
 (the <code>compar</code> parameter). To be able to call the <code>qsort</code> function from
 Java, we must first create a downcall method handle for it, as follows:

 
<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="../../../../resource-files/copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-java">Linker linker = Linker.nativeLinker();
MethodHandle qsort = linker.downcallHandle(
    linker.defaultLookup().find("qsort").orElseThrow(),
        FunctionDescriptor.ofVoid(ADDRESS, JAVA_LONG, JAVA_LONG, ADDRESS)
);
</code></pre>
</div>


 As before, we use <a href="ValueLayout.html#JAVA_LONG"><code>ValueLayout.JAVA_LONG</code></a> to map the C type <code>size_t</code> type,
 and <a href="ValueLayout.html#ADDRESS"><code>ValueLayout.ADDRESS</code></a> for both the first pointer parameter (the array
 pointer) and the last parameter (the function pointer).
 <p>
 To invoke the <code>qsort</code> downcall handle obtained above, we need a function pointer
 to be passed as the last parameter. That is, we need to create a function pointer out
 of an existing method handle. First, let's write a Java method that can compare two
 int elements passed as pointers (i.e. as <a href="MemorySegment.html" title="interface in java.lang.foreign">memory segments</a>):

 
<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="../../../../resource-files/copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-java">class Qsort {
    static int qsortCompare(MemorySegment elem1, MemorySegment elem2) {
        return Integer.compare(elem1.get(JAVA_INT, 0), elem2.get(JAVA_INT, 0));
    }
}
</code></pre>
</div>


 Now let's create a method handle for the comparator method defined above:

 
<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="../../../../resource-files/copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-java">FunctionDescriptor comparDesc = FunctionDescriptor.of(JAVA_INT,
                                                      ADDRESS.withTargetLayout(JAVA_INT),
                                                      ADDRESS.withTargetLayout(JAVA_INT));
MethodHandle comparHandle = MethodHandles.lookup()
                                         .findStatic(Qsort.class, "qsortCompare",
                                                     comparDesc.toMethodType());
</code></pre>
</div>


 First, we create a function descriptor for the function pointer type. Since we know
 that the parameters passed to the comparator method will be pointers to elements of
 a C <code>int[]</code> array, we can specify <a href="ValueLayout.html#JAVA_INT"><code>ValueLayout.JAVA_INT</code></a> as the target
 layout for the address layouts of both parameters. This will allow the comparator
 method to access the contents of the array elements to be compared. We then
 <a href="FunctionDescriptor.html#toMethodType()">turn</a> that function descriptor into
 a suitable <a href="../invoke/MethodType.html" title="class in java.lang.invoke">method type</a> which we then use to
 look up the comparator method handle. We can now create an upcall stub that points to
 that method, and pass it, as a function pointer, to the <code>qsort</code> downcall handle,
 as follows:

 
<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="../../../../resource-files/copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-java">try (Arena arena = Arena.ofConfined()) {
    MemorySegment comparFunc = linker.upcallStub(comparHandle, comparDesc, arena);
    MemorySegment array = arena.allocateFrom(JAVA_INT, 0, 9, 3, 4, 6, 5, 1, 8, 2, 7);
    qsort.invokeExact(array, 10L, 4L, comparFunc);
    int[] sorted = array.toArray(JAVA_INT); // [ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
}
</code></pre>
</div>


 This code creates an off-heap array, copies the contents of a Java array into it, and
 then passes the array to the <code>qsort</code> method handle along with the comparator
 function we obtained from the native linker. After the invocation, the contents
 of the off-heap array will be sorted according to our comparator function, written in
 Java. We then extract a new Java array from the segment, which contains the sorted
 elements.

 <h3 id="by-ref">Functions returning pointers</h3>

 When interacting with native functions, it is common for those functions to allocate
 a region of memory and return a pointer to that region. Let's consider the following
 function from the C standard library:

 
<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="../../../../resource-files/copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-c">void *malloc(size_t size);
</code></pre>
</div>


 The <code>malloc</code> function allocates a region of memory with the given size,
 and returns a pointer to that region of memory, which is later deallocated using
 another function from the C standard library:

 
<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="../../../../resource-files/copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-c">void free(void *ptr);
</code></pre>
</div>


 The <code>free</code> function takes a pointer to a region of memory and deallocates that
 region. In this section we will show how to interact with these native functions,
 with the aim of providing a <em>safe</em> allocation API (the approach outlined below
 can of course be generalized to allocation functions other than <code>malloc</code> and
 <code>free</code>).
 <p>
 First, we need to create the downcall method handles for <code>malloc</code> and
 <code>free</code>, as follows:

 
<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="../../../../resource-files/copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-java">Linker linker = Linker.nativeLinker();

MethodHandle malloc = linker.downcallHandle(
    linker.defaultLookup().find("malloc").orElseThrow(),
    FunctionDescriptor.of(ADDRESS, JAVA_LONG)
);

MethodHandle free = linker.downcallHandle(
    linker.defaultLookup().find("free").orElseThrow(),
    FunctionDescriptor.ofVoid(ADDRESS)
);
</code></pre>
</div>


 When a native function returning a pointer (such as <code>malloc</code>) is invoked using
 a downcall method handle, the Java runtime has no insight into the size or the
 lifetime of the returned pointer. Consider the following code:

 
<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="../../../../resource-files/copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-java">MemorySegment segment = (MemorySegment)malloc.invokeExact(100);
</code></pre>
</div>


 The size of the segment returned by the <code>malloc</code> downcall method handle is
 <a href="MemorySegment.html#wrapping-addresses">zero</a>. Moreover, the scope of the
 returned segment is the global scope. To provide safe access to the segment, we must,
 unsafely, resize the segment to the desired size (100, in this case). It might also
 be desirable to attach the segment to some existing <a href="Arena.html" title="interface in java.lang.foreign">arena</a>, so that
 the lifetime of the region of memory backing the segment can be managed automatically,
 as for any other native segment created directly from Java code. Both of these
 operations are accomplished using the restricted method
 <a href="MemorySegment.html#reinterpret(long,java.lang.foreign.Arena,java.util.function.Consumer)"><code>MemorySegment.reinterpret(long, Arena, Consumer)</code></a><sup><a href="MemorySegment.html#restricted-reinterpret(long,java.lang.foreign.Arena,java.util.function.Consumer)">RESTRICTED</a></sup>, as follows:

 
<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="../../../../resource-files/copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-java">MemorySegment allocateMemory(long byteSize, Arena arena) throws Throwable {
    MemorySegment segment = (MemorySegment) malloc.invokeExact(byteSize); // size = 0, scope = always alive
    return segment.reinterpret(byteSize, arena, s -&gt; {
        try {
            free.invokeExact(s);
        } catch (Throwable e) {
            throw new RuntimeException(e);
        }
    });  // size = byteSize, scope = arena.scope()
}
</code></pre>
</div>


 The <code>allocateMemory</code> method defined above accepts two parameters: a size and an
 arena. The method calls the <code>malloc</code> downcall method handle, and unsafely
 reinterprets the returned segment, by giving it a new size (the size passed to the
 <code>allocateMemory</code> method) and a new scope (the scope of the provided arena).
 The method also specifies a <em>cleanup action</em> to be executed when the provided
 arena is closed. Unsurprisingly, the cleanup action passes the segment to the
 <code>free</code> downcall method handle, to deallocate the underlying region of memory.
 We can use the <code>allocateMemory</code> method as follows:

 
<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="../../../../resource-files/copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-java">try (Arena arena = Arena.ofConfined()) {
    MemorySegment segment = allocateMemory(100, arena);
} // 'free' called here
</code></pre>
</div>


 Note how the segment obtained from <code>allocateMemory</code> acts as any other segment
 managed by the confined arena. More specifically, the obtained segment has the desired
 size, can only be accessed by a single thread (the thread that created the confined
 arena), and its lifetime is tied to the surrounding <em>try-with-resources</em> block.

 <h3 id="variadic-funcs">Variadic functions</h3>

 Variadic functions are C functions that can accept a variable number and type of
 arguments. They are declared with a trailing ellipsis (<code>...</code>) at the end of the
 formal parameter list, such as: <code>void foo(int x, ...);</code>
 The arguments passed in place of the ellipsis are called <em>variadic arguments</em>.
 Variadic functions are, essentially, templates that can be <em>specialized</em> into
 multiple non-variadic functions by replacing the <code>...</code> with a list of
 <em>variadic parameters</em> of a fixed number and type.
 <p>
 It should be noted that values passed as variadic arguments undergo default argument
 promotion in C. For instance, the following argument promotions are applied:
 <ul>
 <li><code>_Bool</code> -&gt; <code>unsigned int</code></li>
 <li><code>[signed] char</code> -&gt; <code>[signed] int</code></li>
 <li><code>[signed] short</code> -&gt; <code>[signed] int</code></li>
 <li><code>float</code> -&gt; <code>double</code></li>
 </ul>
 whereby the signed-ness of the source type corresponds to the signed-ness of the
 promoted type. The complete process of default argument promotion is described in the
 C specification. In effect, these promotions place limits on the types that can be
 used to replace the <code>...</code>, as the variadic parameters of the specialized form
 of a variadic function will always have a promoted type.
 <p>
 The native linker only supports linking the specialized form of a variadic function.
 A variadic function in its specialized form can be linked using a function descriptor
 describing the specialized form. Additionally, the <a href="Linker.Option.html#firstVariadicArg(int)"><code>Linker.Option.firstVariadicArg(int)</code></a>
 linker option must be provided to indicate the first variadic parameter in the
 parameter list. The corresponding argument layout (if any), and all following
 argument layouts in the specialized function descriptor, are called
 <em>variadic argument layouts</em>.
 <p>
 The native linker does not automatically perform default argument promotions. However,
 since passing an argument of a non-promoted type as a variadic argument is not
 supported in C, the native linker will reject an attempt to link a specialized
 function descriptor with any variadic argument value layouts corresponding to a
 non-promoted C type. Since the size of the C <code>int</code> type is platform-specific,
 exactly which layouts will be rejected is platform-specific as well. As an example:
 on Linux/x64 the layouts corresponding to the C types <code>_Bool</code>,
 <code>(unsigned) char</code>, <code>(unsigned) short</code>, and <code>float</code> (among others),
 will be rejected by the linker. The <a href="#canonicalLayouts()"><code>canonicalLayouts()</code></a> method can be used to
 find which layout corresponds to a particular C type.
 <p>
 A well-known variadic function is the <code>printf</code> function, defined in the
 C standard library:

 
<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="../../../../resource-files/copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-c">int printf(const char *format, ...);
</code></pre>
</div>


 This function takes a format string, and a number of additional arguments (the number
 of such arguments is dictated by the format string). Consider the following
 variadic call:

 
<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="../../../../resource-files/copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-c">printf("%d plus %d equals %d", 2, 2, 4);
</code></pre>
</div>


 To perform an equivalent call using a downcall method handle we must create a function
 descriptor which describes the specialized signature of the C function we want to
 call. This descriptor must include an additional layout for each variadic argument we
 intend to provide. In this case, the specialized signature of the C function is
 <code>(char*, int, int, int)</code> as the format string accepts three integer parameters.
 We then need to use a <a href="Linker.Option.html#firstVariadicArg(int)">linker option</a>
 to specify the position of the first variadic layout in the provided function
 descriptor (starting from 0). In this case, since the first parameter is the format
 string (a non-variadic argument), the first variadic index needs to be set to 1, as
 follows:

 
<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="../../../../resource-files/copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-java">Linker linker = Linker.nativeLinker();
MethodHandle printf = linker.downcallHandle(
    linker.defaultLookup().find("printf").orElseThrow(),
        FunctionDescriptor.of(JAVA_INT, ADDRESS, JAVA_INT, JAVA_INT, JAVA_INT),
        Linker.Option.firstVariadicArg(1) // first int is variadic
);
</code></pre>
</div>


 We can then call the specialized downcall handle as usual:

 
<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="../../../../resource-files/copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-java"> try (Arena arena = Arena.ofConfined()) {
     //prints "2 plus 2 equals 4"
     int res = (int)printf.invokeExact(arena.allocateFrom("%d plus %d equals %d"), 2, 2, 4);
 }
</code></pre>
</div>


 <h2 id="safety">Safety considerations</h2>

 Creating a downcall method handle is intrinsically unsafe. A symbol in a foreign
 library does not, in general, contain enough signature information (e.g. arity and
 types of foreign function parameters). As a consequence, the linker runtime cannot
 validate linkage requests. When a client interacts with a downcall method handle
 obtained through an invalid linkage request (e.g. by specifying a function descriptor
 featuring too many argument layouts), the result of such interaction is unspecified
 and can lead to JVM crashes.
 <p>
 When an upcall stub is passed to a foreign function, a JVM crash might occur, if the
 foreign code casts the function pointer associated with the upcall stub to a type that
 is incompatible with the type of the upcall stub, and then attempts to invoke the
 function through the resulting function pointer. Moreover, if the method handle
 associated with an upcall stub returns a <a href="MemorySegment.html" title="interface in java.lang.foreign">memory segment</a>,
 clients must ensure that this address cannot become invalid after the upcall is
 completed. This can lead to unspecified behavior, and even JVM crashes, since an
 upcall is typically executed in the context of a downcall method handle invocation.</div>
<dl class="notes">
<dt>Implementation Requirements:</dt>
<dd>Implementations of this interface are immutable, thread-safe and
 <a href="../../../../java.base/java/lang/doc-files/ValueBased.html">value-based</a>.</dd>
<dt>Since:</dt>
<dd>22</dd>
</dl>
</div>
</section>
<section class="summary">
<ul class="summary-list">
<!-- ======== NESTED CLASS SUMMARY ======== -->
<li>
<section class="nested-class-summary" id="nested-class-summary">
<h2>Nested Class Summary</h2>
<div class="caption"><span>Nested Classes</span></div>
<div class="summary-table three-column-summary">
<div class="table-header col-first">Modifier and Type</div>
<div class="table-header col-second">Interface</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color"><code>static interface&nbsp;</code></div>
<div class="col-second even-row-color"><code><a href="Linker.Option.html" class="type-name-link" title="interface in java.lang.foreign">Linker.Option</a></code></div>
<div class="col-last even-row-color">
<div class="block">A linker option is used to provide additional parameters to a linkage request.</div>
</div>
</div>
</section>
</li>
<!-- ========== METHOD SUMMARY =========== -->
<li>
<section class="method-summary" id="method-summary">
<h2>Method Summary</h2>
<div id="method-summary-table">
<div class="table-tabs" role="tablist" aria-orientation="horizontal"><button id="method-summary-table-tab0" role="tab" aria-selected="true" aria-controls="method-summary-table.tabpanel" tabindex="0" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table', 3)" class="active-table-tab">All Methods</button><button id="method-summary-table-tab1" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab1', 3)" class="table-tab">Static Methods</button><button id="method-summary-table-tab2" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab2', 3)" class="table-tab">Instance Methods</button><button id="method-summary-table-tab3" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab3', 3)" class="table-tab">Abstract Methods</button></div>
<div id="method-summary-table.tabpanel" role="tabpanel">
<div class="summary-table three-column-summary" aria-labelledby="method-summary-table-tab0">
<div class="table-header col-first">Modifier and Type</div>
<div class="table-header col-second">Method</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="../../util/Map.html" title="interface in java.util">Map</a><wbr>&lt;<a href="../String.html" title="class in java.lang">String</a>,<wbr><a href="MemoryLayout.html" title="interface in java.lang.foreign">MemoryLayout</a>&gt;</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#canonicalLayouts()" class="member-name-link">canonicalLayouts</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Returns an unmodifiable mapping between the names of data types used by the ABI
          implemented by this linker and their <em>canonical layouts</em>.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="SymbolLookup.html" title="interface in java.lang.foreign">SymbolLookup</a></code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#defaultLookup()" class="member-name-link">defaultLookup</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Returns a symbol lookup for symbols in a set of commonly used libraries.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="../invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#downcallHandle(java.lang.foreign.FunctionDescriptor,java.lang.foreign.Linker.Option...)" class="member-name-link">downcallHandle</a><wbr>(<a href="FunctionDescriptor.html" title="interface in java.lang.foreign">FunctionDescriptor</a>&nbsp;function,
 <a href="Linker.Option.html" title="interface in java.lang.foreign">Linker.Option</a>...&nbsp;options)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block"><span class="restricted-label">Restricted.</span></div>
<div class="block">Creates a method handle that is used to call a foreign function with
 the given signature.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="../invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#downcallHandle(java.lang.foreign.MemorySegment,java.lang.foreign.FunctionDescriptor,java.lang.foreign.Linker.Option...)" class="member-name-link">downcallHandle</a><wbr>(<a href="MemorySegment.html" title="interface in java.lang.foreign">MemorySegment</a>&nbsp;address,
 <a href="FunctionDescriptor.html" title="interface in java.lang.foreign">FunctionDescriptor</a>&nbsp;function,
 <a href="Linker.Option.html" title="interface in java.lang.foreign">Linker.Option</a>...&nbsp;options)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block"><span class="restricted-label">Restricted.</span></div>
<div class="block">Creates a method handle that is used to call a foreign function with
 the given signature and address.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1"><code>static <a href="Linker.html" title="interface in java.lang.foreign">Linker</a></code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1"><code><a href="#nativeLinker()" class="member-name-link">nativeLinker</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1">
<div class="block">Returns a linker for the ABI associated with the underlying native platform.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="MemorySegment.html" title="interface in java.lang.foreign">MemorySegment</a></code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#upcallStub(java.lang.invoke.MethodHandle,java.lang.foreign.FunctionDescriptor,java.lang.foreign.Arena,java.lang.foreign.Linker.Option...)" class="member-name-link">upcallStub</a><wbr>(<a href="../invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target,
 <a href="FunctionDescriptor.html" title="interface in java.lang.foreign">FunctionDescriptor</a>&nbsp;function,
 <a href="Arena.html" title="interface in java.lang.foreign">Arena</a>&nbsp;arena,
 <a href="Linker.Option.html" title="interface in java.lang.foreign">Linker.Option</a>...&nbsp;options)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block"><span class="restricted-label">Restricted.</span></div>
<div class="block">Creates an upcall stub which can be passed to other foreign functions as a
 function pointer, associated with the given arena.</div>
</div>
</div>
</div>
</div>
</section>
</li>
</ul>
</section>
<section class="details">
<ul class="details-list">
<!-- ============ METHOD DETAIL ========== -->
<li>
<section class="method-details" id="method-detail">
<h2>Method Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="nativeLinker()">
<h3>nativeLinker</h3>
<div class="horizontal-scroll">
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type"><a href="Linker.html" title="interface in java.lang.foreign">Linker</a></span>&nbsp;<span class="element-name">nativeLinker</span>()</div>
<div class="block">Returns a linker for the ABI associated with the underlying native platform.
 <p>
 The underlying native platform is the combination of OS and processor where the
 Java runtime is currently executing.</div>
<dl class="notes">
<dt>API Note:</dt>
<dd>It is not currently possible to obtain a linker for a different
          combination of OS and processor.</dd>
<dt>Implementation Requirements:</dt>
<dd>A native linker implementation is guaranteed to provide canonical
           layouts for <a href="#describing-c-sigs">basic C types</a>.</dd>
<dt>Implementation Note:</dt>
<dd>The libraries exposed by the <a href="#defaultLookup()">default lookup</a>
           associated with the returned linker are the native libraries loaded in
           the process where the Java runtime is currently executing. For example,
           on Linux, these libraries typically include <code>libc</code>, <code>libm</code>
           and <code>libdl</code>.</dd>
<dt>Returns:</dt>
<dd>a linker for the ABI associated with the underlying native platform</dd>
</dl>
</div>
</section>
</li>
<li>
<section class="detail" id="downcallHandle(java.lang.foreign.MemorySegment,java.lang.foreign.FunctionDescriptor,java.lang.foreign.Linker.Option...)">
<h3>downcallHandle</h3>
<div class="horizontal-scroll">
<div class="member-signature"><span class="modifiers">sealed</span>&nbsp;<span class="return-type"><a href="../invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></span>&nbsp;<span class="element-name">downcallHandle</span><wbr><span class="parameters">(<a href="MemorySegment.html" title="interface in java.lang.foreign">MemorySegment</a>&nbsp;address,
 <a href="FunctionDescriptor.html" title="interface in java.lang.foreign">FunctionDescriptor</a>&nbsp;function,
 <a href="Linker.Option.html" title="interface in java.lang.foreign">Linker.Option</a>...&nbsp;options)</span></div>
<div class="restricted-block" id="restricted-downcallHandle(java.lang.foreign.MemorySegment,java.lang.foreign.FunctionDescriptor,java.lang.foreign.Linker.Option...)"><span class="restricted-label"><code>downcallHandle</code> is a restricted method of the Java platform.</span>
<div class="restricted-comment">Programs can only use <code>downcallHandle</code> when access to restricted methods is enabled.</div>
<div class="restricted-comment">Restricted methods are unsafe, and, if used incorrectly, might crash the JVM or result in memory corruption.</div>
</div>
<div class="block">Creates a method handle that is used to call a foreign function with
 the given signature and address.
 <p>
 Calling this method is equivalent to the following code:
 
<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="../../../../resource-files/copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-java">linker.downcallHandle(function).bindTo(symbol);
</code></pre>
</div>
</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>address</code> - the native memory segment whose
                 <a href="MemorySegment.html#address()">base address</a> is the address
                 of the target foreign function</dd>
<dd><code>function</code> - the function descriptor of the target foreign function</dd>
<dd><code>options</code> - the linker options associated with this linkage request</dd>
<dt>Returns:</dt>
<dd>a downcall method handle</dd>
<dt>Throws:</dt>
<dd><code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if the provided function descriptor is not
         supported by this linker</dd>
<dd><code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if <code>!address.isNative()</code>, or if
         <code>address.equals(MemorySegment.NULL)</code></dd>
<dd><code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if an invalid combination of linker options
         is given</dd>
<dd><code><a href="../IllegalCallerException.html" title="class in java.lang">IllegalCallerException</a></code> - If the caller is in a module that does not have
         native access enabled</dd>
<dt>See Also:</dt>
<dd>
<ul class="tag-list">
<li><a href="SymbolLookup.html" title="interface in java.lang.foreign"><code>SymbolLookup</code></a></li>
</ul>
</dd>
</dl>
</div>
</section>
</li>
<li>
<section class="detail" id="downcallHandle(java.lang.foreign.FunctionDescriptor,java.lang.foreign.Linker.Option...)">
<h3>downcallHandle</h3>
<div class="horizontal-scroll">
<div class="member-signature"><span class="modifiers">sealed</span>&nbsp;<span class="return-type"><a href="../invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></span>&nbsp;<span class="element-name">downcallHandle</span><wbr><span class="parameters">(<a href="FunctionDescriptor.html" title="interface in java.lang.foreign">FunctionDescriptor</a>&nbsp;function,
 <a href="Linker.Option.html" title="interface in java.lang.foreign">Linker.Option</a>...&nbsp;options)</span></div>
<div class="restricted-block" id="restricted-downcallHandle(java.lang.foreign.FunctionDescriptor,java.lang.foreign.Linker.Option...)"><span class="restricted-label"><code>downcallHandle</code> is a restricted method of the Java platform.</span>
<div class="restricted-comment">Programs can only use <code>downcallHandle</code> when access to restricted methods is enabled.</div>
<div class="restricted-comment">Restricted methods are unsafe, and, if used incorrectly, might crash the JVM or result in memory corruption.</div>
</div>
<div class="block">Creates a method handle that is used to call a foreign function with
 the given signature.
 <p>
 The Java <a href="../invoke/MethodType.html" title="class in java.lang.invoke">method type</a> associated with the
 returned method handle is <a href="FunctionDescriptor.html#toMethodType()">derived</a>
 from the argument and return layouts in the function descriptor, but features an
 additional leading parameter of type <a href="MemorySegment.html" title="interface in java.lang.foreign"><code>MemorySegment</code></a>, from which the address
 of the target foreign function is derived. Moreover, if the function descriptor's
 return layout is a group layout, the resulting downcall method handle accepts an
 additional leading parameter of type <a href="SegmentAllocator.html" title="interface in java.lang.foreign"><code>SegmentAllocator</code></a>, which is used by
 the linker runtime to allocate the memory region associated with the struct
 returned by the downcall method handle.
 <p>
 Upon invoking a downcall method handle, the linker provides the following
 guarantees for any argument <code>A</code> of type <a href="MemorySegment.html" title="interface in java.lang.foreign"><code>MemorySegment</code></a> whose
 corresponding layout is an <a href="AddressLayout.html" title="interface in java.lang.foreign">address layout</a>:
 <ul>
     <li><code>A.scope().isAlive() == true</code>. Otherwise, the invocation
         throws <a href="../IllegalStateException.html" title="class in java.lang"><code>IllegalStateException</code></a>;</li>
     <li>The invocation occurs in a thread <code>T</code> such that
         <code>A.isAccessibleBy(T) == true</code>.
         Otherwise, the invocation throws <a href="../WrongThreadException.html" title="class in java.lang"><code>WrongThreadException</code></a>; and</li>
     <li><code>A</code> is kept alive during the invocation. For instance,
         if <code>A</code> has been obtained using a <a href="Arena.html#ofShared()">shared arena</a>,
         any attempt to <a href="Arena.html#close()">close</a> the arena while the
         downcall method handle is still executing will result in an
         <a href="../IllegalStateException.html" title="class in java.lang"><code>IllegalStateException</code></a>.</li>
</ul>
 <p>
 Moreover, if the provided function descriptor's return layout is an
 <a href="AddressLayout.html" title="interface in java.lang.foreign">address layout</a>, invoking the returned method handle
 will return a native segment associated with the global scope. Under normal
 conditions, the size of the returned segment is <code>0</code>. However, if the
 function descriptor's return layout has a
 <a href="AddressLayout.html#targetLayout()">target layout</a> <code>T</code>, then the size
 of the returned segment is set to <code>T.byteSize()</code>.
 <p>
 The returned method handle will throw an <a href="../IllegalArgumentException.html" title="class in java.lang"><code>IllegalArgumentException</code></a> if the
 <a href="MemorySegment.html" title="interface in java.lang.foreign"><code>MemorySegment</code></a> representing the target address of the foreign function is
 the <a href="MemorySegment.html#NULL"><code>MemorySegment.NULL</code></a> address. If an argument is a <a href="MemorySegment.html" title="interface in java.lang.foreign"><code>MemorySegment</code></a>,
 whose corresponding layout is a <a href="GroupLayout.html" title="interface in java.lang.foreign">group layout</a>, the linker
 might attempt to access the contents of the segment. As such, one of the
 exceptions specified by the <a href="MemorySegment.html#get(java.lang.foreign.ValueLayout.OfByte,long)"><code>MemorySegment.get(ValueLayout.OfByte, long)</code></a> or
 the <a href="MemorySegment.html#copy(java.lang.foreign.MemorySegment,long,java.lang.foreign.MemorySegment,long,long)"><code>MemorySegment.copy(MemorySegment, long, MemorySegment, long, long)</code></a>
 methods may be thrown. If an argument is a <a href="MemorySegment.html" title="interface in java.lang.foreign"><code>MemorySegment</code></a> whose
 corresponding layout is an <a href="AddressLayout.html" title="interface in java.lang.foreign">address layout</a>, the linker
 will throw an <a href="../IllegalArgumentException.html" title="class in java.lang"><code>IllegalArgumentException</code></a> if the segment is a heap memory
 segment, unless heap memory segments are explicitly allowed through the
 <a href="Linker.Option.html#critical(boolean)"><code>Linker.Option.critical(boolean)</code></a> linker option. The returned method handle
 will additionally throw <a href="../NullPointerException.html" title="class in java.lang"><code>NullPointerException</code></a> if any argument passed to it
 is <code>null</code>.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>function</code> - the function descriptor of the target foreign function</dd>
<dd><code>options</code> - the linker options associated with this linkage request</dd>
<dt>Returns:</dt>
<dd>a downcall method handle</dd>
<dt>Throws:</dt>
<dd><code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if the provided function descriptor is not
         supported by this linker</dd>
<dd><code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if an invalid combination of linker options
         is given</dd>
<dd><code><a href="../IllegalCallerException.html" title="class in java.lang">IllegalCallerException</a></code> - If the caller is in a module that does not have
         native access enabled</dd>
</dl>
</div>
</section>
</li>
<li>
<section class="detail" id="upcallStub(java.lang.invoke.MethodHandle,java.lang.foreign.FunctionDescriptor,java.lang.foreign.Arena,java.lang.foreign.Linker.Option...)">
<h3>upcallStub</h3>
<div class="horizontal-scroll">
<div class="member-signature"><span class="modifiers">sealed</span>&nbsp;<span class="return-type"><a href="MemorySegment.html" title="interface in java.lang.foreign">MemorySegment</a></span>&nbsp;<span class="element-name">upcallStub</span><wbr><span class="parameters">(<a href="../invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a>&nbsp;target,
 <a href="FunctionDescriptor.html" title="interface in java.lang.foreign">FunctionDescriptor</a>&nbsp;function,
 <a href="Arena.html" title="interface in java.lang.foreign">Arena</a>&nbsp;arena,
 <a href="Linker.Option.html" title="interface in java.lang.foreign">Linker.Option</a>...&nbsp;options)</span></div>
<div class="restricted-block" id="restricted-upcallStub(java.lang.invoke.MethodHandle,java.lang.foreign.FunctionDescriptor,java.lang.foreign.Arena,java.lang.foreign.Linker.Option...)"><span class="restricted-label"><code>upcallStub</code> is a restricted method of the Java platform.</span>
<div class="restricted-comment">Programs can only use <code>upcallStub</code> when access to restricted methods is enabled.</div>
<div class="restricted-comment">Restricted methods are unsafe, and, if used incorrectly, might crash the JVM or result in memory corruption.</div>
</div>
<div class="block">Creates an upcall stub which can be passed to other foreign functions as a
 function pointer, associated with the given arena. Calling such a function
 pointer from foreign code will result in the execution of the provided method
 handle.
 <p>
 The returned memory segment's address points to the newly allocated upcall stub,
 and is associated with the provided arena. As such, the lifetime of the returned
 upcall stub segment is controlled by the provided arena. For instance, if the
 provided arena is a confined arena, the returned upcall stub segment will be
 deallocated when the provided confined arena is <a href="Arena.html#close()">closed</a>.
 <p>
 An upcall stub argument whose corresponding layout is an
 <a href="AddressLayout.html" title="interface in java.lang.foreign">address layout</a> is a native segment associated with the
 global scope. Under normal conditions, the size of this segment argument is
 <code>0</code>. However, if the address layout has a
 <a href="AddressLayout.html#targetLayout()">target layout</a> <code>T</code>, then the size
 of the segment argument is set to <code>T.byteSize()</code>.
 <p>
 The target method handle should not throw any exceptions. If the target method
 handle does throw an exception, the JVM will terminate abruptly. To avoid this,
 clients should wrap the code in the target method handle in a try/catch block to
 catch any unexpected exceptions. This can be done using the
 <a href="../invoke/MethodHandles.html#catchException(java.lang.invoke.MethodHandle,java.lang.Class,java.lang.invoke.MethodHandle)"><code>MethodHandles.catchException(MethodHandle, Class, MethodHandle)</code></a>
 method handle combinator, and handle exceptions as desired in the corresponding
 catch block.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>target</code> - the target method handle</dd>
<dd><code>function</code> - the upcall stub function descriptor</dd>
<dd><code>arena</code> - the arena associated with the returned upcall stub segment</dd>
<dd><code>options</code> - the linker options associated with this linkage request</dd>
<dt>Returns:</dt>
<dd>a zero-length segment whose address is the address of the upcall stub</dd>
<dt>Throws:</dt>
<dd><code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if the provided function descriptor is not
         supported by this linker</dd>
<dd><code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if the type of <code>target</code> is incompatible
         with the type <a href="FunctionDescriptor.html#toMethodType()">derived</a>
         from <code>function</code></dd>
<dd><code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if it is determined that the target method handle
         can throw an exception</dd>
<dd><code><a href="../IllegalStateException.html" title="class in java.lang">IllegalStateException</a></code> - if <code>arena.scope().isAlive() == false</code></dd>
<dd><code><a href="../WrongThreadException.html" title="class in java.lang">WrongThreadException</a></code> - if <code>arena</code> is a confined arena, and this method
         is called from a thread <code>T</code>, other than the arena's owner thread</dd>
<dd><code><a href="../IllegalCallerException.html" title="class in java.lang">IllegalCallerException</a></code> - If the caller is in a module that does not have
         native access enabled</dd>
</dl>
</div>
</section>
</li>
<li>
<section class="detail" id="defaultLookup()">
<h3>defaultLookup</h3>
<div class="horizontal-scroll">
<div class="member-signature"><span class="return-type"><a href="SymbolLookup.html" title="interface in java.lang.foreign">SymbolLookup</a></span>&nbsp;<span class="element-name">defaultLookup</span>()</div>
<div class="block">Returns a symbol lookup for symbols in a set of commonly used libraries.
 <p>
 Each <a href="Linker.html" title="interface in java.lang.foreign"><code>Linker</code></a> is responsible for choosing libraries that are widely
 recognized as useful on the OS and processor combination supported by the
 <a href="Linker.html" title="interface in java.lang.foreign"><code>Linker</code></a>. Accordingly, the precise set of symbols exposed by the symbol
 lookup is unspecified; it varies from one <a href="Linker.html" title="interface in java.lang.foreign"><code>Linker</code></a> to another.</div>
<dl class="notes">
<dt>Implementation Note:</dt>
<dd>It is strongly recommended that the result of <a href="#defaultLookup()"><code>defaultLookup()</code></a>
           exposes a set of symbols that is stable over time. Clients of
           <a href="#defaultLookup()"><code>defaultLookup()</code></a> are likely to fail if a symbol that was
           previously exposed by the symbol lookup is no longer exposed.
           <p>If an implementer provides <a href="Linker.html" title="interface in java.lang.foreign"><code>Linker</code></a> implementations for
           multiple OS and processor combinations, then it is strongly
           recommended that the result of <a href="#defaultLookup()"><code>defaultLookup()</code></a> exposes, as much
           as possible, a consistent set of symbols across all the OS and processor
           combinations.</dd>
<dt>Returns:</dt>
<dd>a symbol lookup for symbols in a set of commonly used libraries</dd>
</dl>
</div>
</section>
</li>
<li>
<section class="detail" id="canonicalLayouts()">
<h3>canonicalLayouts</h3>
<div class="horizontal-scroll">
<div class="member-signature"><span class="return-type"><a href="../../util/Map.html" title="interface in java.util">Map</a>&lt;<a href="../String.html" title="class in java.lang">String</a>,<wbr><a href="MemoryLayout.html" title="interface in java.lang.foreign">MemoryLayout</a>&gt;</span>&nbsp;<span class="element-name">canonicalLayouts</span>()</div>
<div class="block">Returns an unmodifiable mapping between the names of data types used by the ABI
          implemented by this linker and their <em>canonical layouts</em>.
 <p>
 Each <a href="Linker.html" title="interface in java.lang.foreign"><code>Linker</code></a> is responsible for choosing the data types that are widely
 recognized as useful on the OS and processor combination supported by the
 <a href="Linker.html" title="interface in java.lang.foreign"><code>Linker</code></a>. Accordingly, the precise set of data type names and canonical
 layouts exposed by the linker are unspecified; they vary from one <a href="Linker.html" title="interface in java.lang.foreign"><code>Linker</code></a>
 to another.</div>
<dl class="notes">
<dt>Implementation Note:</dt>
<dd>It is strongly recommended that the result of <a href="#canonicalLayouts()"><code>canonicalLayouts()</code></a>
           exposes a set of symbols that is stable over time. Clients of
           <a href="#canonicalLayouts()"><code>canonicalLayouts()</code></a> are likely to fail if a data type that was
           previously exposed by the linker is no longer exposed, or if its
           canonical layout is updated.
           <p>If an implementer provides <a href="Linker.html" title="interface in java.lang.foreign"><code>Linker</code></a> implementations for multiple
           OS and processor combinations, then it is strongly recommended that the
           result of <a href="#canonicalLayouts()"><code>canonicalLayouts()</code></a> exposes, as much as possible,
           a consistent set of symbols across all the OS and processor combinations.</dd>
<dt>Returns:</dt>
<dd>an unmodifiable mapping between the names of data types used by the ABI
          implemented by this linker and their <em>canonical layouts</em></dd>
</dl>
</div>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
<!-- ========= END OF CLASS DATA ========= -->
</main>
<footer role="contentinfo">
<hr>
<p class="legal-copy"><small><a href="https://bugreport.java.com/bugreport/">Report a bug or suggest an enhancement</a><br> For further API reference and developer documentation see the <a href="https://docs.oracle.com/pls/topic/lookup?ctx=javase22&amp;id=homepage" target="_blank">Java SE Documentation</a>, which contains more detailed, developer-targeted descriptions with conceptual overviews, definitions of terms, workarounds, and working code examples. <a href="https://docs.oracle.com/en/java/javase/index.html">Other versions.</a><br> Java is a trademark or registered trademark of Oracle and/or its affiliates in the US and other countries.<br> <a href="../../../../../legal/copyright.html">Copyright</a> &copy; 1993, 2024, Oracle and/or its affiliates, 500 Oracle Parkway, Redwood Shores, CA 94065 USA.<br>All rights reserved. Use is subject to <a href="https://www.oracle.com/java/javase/terms/license/java22speclicense.html">license terms</a> and the <a href="https://www.oracle.com/technetwork/java/redist-137594.html">documentation redistribution policy</a>. <!-- Version 22.0.2+9-70 --></small></p>
</footer>
</body>
</html>
