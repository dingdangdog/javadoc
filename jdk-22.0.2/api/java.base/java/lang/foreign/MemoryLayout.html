<!DOCTYPE HTML>
<html lang="en">
<head>
<!-- Generated by javadoc (22) -->
<title>MemoryLayout (Java SE 22 &amp; JDK 22)</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="description" content="declaration: module: java.base, package: java.lang.foreign, interface: MemoryLayout">
<meta name="generator" content="javadoc/ClassWriter">
<meta name="keywords" content="java.lang.foreign.MemoryLayout interface">
<meta name="keywords" content="byteSize()">
<meta name="keywords" content="name()">
<meta name="keywords" content="withName()">
<meta name="keywords" content="withoutName()">
<meta name="keywords" content="byteAlignment()">
<meta name="keywords" content="withByteAlignment()">
<meta name="keywords" content="scale()">
<meta name="keywords" content="scaleHandle()">
<meta name="keywords" content="byteOffset()">
<meta name="keywords" content="byteOffsetHandle()">
<meta name="keywords" content="varHandle()">
<meta name="keywords" content="arrayElementVarHandle()">
<meta name="keywords" content="sliceHandle()">
<meta name="keywords" content="select()">
<meta name="keywords" content="equals()">
<meta name="keywords" content="hashCode()">
<meta name="keywords" content="toString()">
<meta name="keywords" content="paddingLayout()">
<meta name="keywords" content="sequenceLayout()">
<meta name="keywords" content="structLayout()">
<meta name="keywords" content="unionLayout()">
<link rel="stylesheet" type="text/css" href="../../../../resource-files/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../resource-files/stylesheet.css" title="Style">
<script type="text/javascript" src="../../../../script-files/script.js"></script>
<script type="text/javascript" src="../../../../script-files/jquery-3.6.1.min.js"></script>
<script type="text/javascript" src="../../../../script-files/jquery-ui.min.js"></script>
</head>
<body class="class-declaration-page">
<script type="text/javascript">var pathtoroot = "../../../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<header role="banner">
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="top-nav" id="navbar-top"><button id="navbar-toggle-button" aria-controls="navbar-top" aria-expanded="false" aria-label="Toggle navigation links"><span class="nav-bar-toggle-icon">&nbsp;</span><span class="nav-bar-toggle-icon">&nbsp;</span><span class="nav-bar-toggle-icon">&nbsp;</span></button>
<div class="skip-nav"><a href="#skip-navbar-top" title="Skip navigation links">Skip navigation links</a></div>
<div class="about-language"><div style="margin-top: 14px;"><strong>Java SE 22 &amp; JDK 22</strong> </div></div>
<ul id="navbar-top-firstrow" class="nav-list" title="Navigation">
<li><a href="../../../../index.html">Overview</a></li>
<li><a href="../../../module-summary.html">Module</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="class-use/MemoryLayout.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../preview-list.html">Preview</a></li>
<li><a href="../../../../new-list.html">New</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-files/index-1.html">Index</a></li>
<li><a href="../../../../help-doc.html#class">Help</a></li>
</ul>
<ul class="sub-nav-list-small">
<li>
<p>Summary:</p>
<ul>
<li><a href="#nested-class-summary">Nested</a></li>
<li>Field</li>
<li>Constr</li>
<li><a href="#method-summary">Method</a></li>
</ul>
</li>
<li>
<p>Detail:</p>
<ul>
<li>Field</li>
<li>Constr</li>
<li><a href="#method-detail">Method</a></li>
</ul>
</li>
</ul>
</div>
<div class="sub-nav">
<div id="navbar-sub-list">
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li><a href="#nested-class-summary">Nested</a>&nbsp;|&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method-summary">Method</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li>Field&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method-detail">Method</a></li>
</ul>
</div>
<div class="nav-list-search"><a href="../../../../search.html">SEARCH</a>
<input type="text" id="search-input" disabled placeholder="Search">
<input type="reset" id="reset-button" disabled value="reset">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<span class="skip-nav" id="skip-navbar-top"></span></nav>
</header>
<main role="main">
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="sub-title"><span class="module-label-in-type">Module</span>&nbsp;<a href="../../../module-summary.html">java.base</a></div>
<div class="sub-title"><span class="package-label-in-type">Package</span>&nbsp;<a href="package-summary.html">java.lang.foreign</a></div>
<h1 title="Interface MemoryLayout" class="title">Interface MemoryLayout</h1>
</div>
<section class="class-description" id="class-description">
<div class="horizontal-scroll">
<dl class="notes">
<dt>All Known Subinterfaces:</dt>
<dd><code><a href="AddressLayout.html" title="interface in java.lang.foreign">AddressLayout</a></code>, <code><a href="GroupLayout.html" title="interface in java.lang.foreign">GroupLayout</a></code>, <code><a href="PaddingLayout.html" title="interface in java.lang.foreign">PaddingLayout</a></code>, <code><a href="SequenceLayout.html" title="interface in java.lang.foreign">SequenceLayout</a></code>, <code><a href="StructLayout.html" title="interface in java.lang.foreign">StructLayout</a></code>, <code><a href="UnionLayout.html" title="interface in java.lang.foreign">UnionLayout</a></code>, <code><a href="ValueLayout.html" title="interface in java.lang.foreign">ValueLayout</a></code>, <code><a href="ValueLayout.OfBoolean.html" title="interface in java.lang.foreign">ValueLayout.OfBoolean</a></code>, <code><a href="ValueLayout.OfByte.html" title="interface in java.lang.foreign">ValueLayout.OfByte</a></code>, <code><a href="ValueLayout.OfChar.html" title="interface in java.lang.foreign">ValueLayout.OfChar</a></code>, <code><a href="ValueLayout.OfDouble.html" title="interface in java.lang.foreign">ValueLayout.OfDouble</a></code>, <code><a href="ValueLayout.OfFloat.html" title="interface in java.lang.foreign">ValueLayout.OfFloat</a></code>, <code><a href="ValueLayout.OfInt.html" title="interface in java.lang.foreign">ValueLayout.OfInt</a></code>, <code><a href="ValueLayout.OfLong.html" title="interface in java.lang.foreign">ValueLayout.OfLong</a></code>, <code><a href="ValueLayout.OfShort.html" title="interface in java.lang.foreign">ValueLayout.OfShort</a></code></dd>
</dl>
<hr>
<div class="type-signature"><span class="modifiers">public sealed interface </span><span class="element-name type-name-label">MemoryLayout</span>
<span class="permits">permits <a href="SequenceLayout.html" title="interface in java.lang.foreign">SequenceLayout</a>, <a href="GroupLayout.html" title="interface in java.lang.foreign">GroupLayout</a>, <a href="PaddingLayout.html" title="interface in java.lang.foreign">PaddingLayout</a>, <a href="ValueLayout.html" title="interface in java.lang.foreign">ValueLayout</a></span></div>
<div class="block">A memory layout describes the contents of a memory segment.
 <p>
 There are two leaves in the layout hierarchy, <a href="ValueLayout.html" title="interface in java.lang.foreign">value layouts</a>,
 which are used to represent values of given size and kind and
 <a href="PaddingLayout.html" title="interface in java.lang.foreign">padding layouts</a> which are used, as the name suggests, to
 represent a portion of a memory segment whose contents should be ignored, and which
 are primarily present for alignment reasons. Some common value layout constants, such
 as <a href="ValueLayout.html#JAVA_INT"><code>ValueLayout.JAVA_INT</code></a> and <a href="ValueLayout.html#JAVA_FLOAT_UNALIGNED"><code>ValueLayout.JAVA_FLOAT_UNALIGNED</code></a> are
 defined in the <a href="ValueLayout.html" title="interface in java.lang.foreign"><code>ValueLayout</code></a> class. A special kind of value layout, namely an
 <a href="AddressLayout.html" title="interface in java.lang.foreign">address layout</a>, is used to model values that denote the
 address of a region of memory.
 <p>
 More complex layouts can be derived from simpler ones: a
 <a href="SequenceLayout.html" title="interface in java.lang.foreign">sequence layout</a> denotes a homogeneous repetition of zero
 or more occurrences of an element layout; a <a href="GroupLayout.html" title="interface in java.lang.foreign">group layout</a>
 denotes a heterogeneous aggregation of zero or more member layouts. Group layouts
 come in two flavors: <a href="StructLayout.html" title="interface in java.lang.foreign">struct layouts</a>, where member layouts
 are laid out one after the other, and <a href="UnionLayout.html" title="interface in java.lang.foreign">union layouts</a> where
 member layouts are laid out at the same starting offset.
 <p>
 Layouts can be optionally associated with a <em>name</em>. A layout name can be
 referred to when constructing <a href="MemoryLayout.html#layout-paths"><em>layout paths</em></a>.
 <p>
 Consider the following struct declaration in C:

 
<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="../../../../resource-files/copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-c">typedef struct {
    char kind;
    int value;
} TaggedValues[5];
</code></pre>
</div>


 The above declaration can be modeled using a layout object, as follows:

 
<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="../../../../resource-files/copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-java">SequenceLayout TAGGED_VALUES = MemoryLayout.sequenceLayout(5,
    MemoryLayout.structLayout(
        ValueLayout.JAVA_BYTE.withName("kind"),
        MemoryLayout.paddingLayout(3),
        ValueLayout.JAVA_INT.withName("value")
    )
).withName("TaggedValues");
</code></pre>
</div>


 <h2 id="layout-align">Characteristics of memory layouts</h2>

 All layouts have a <em>size</em> (expressed in bytes), which is defined as follows:
 <ul>
     <li>The size of a value layout is determined by the <a href="ValueLayout.html#carrier()">ValueLayout.carrier()</a>
     associated with the value layout. That is, the constant <a href="ValueLayout.html#JAVA_INT"><code>ValueLayout.JAVA_INT</code></a>
     has carrier <code>int</code>, and size of 4 bytes;</li>
     <li>The size of an address layout is platform-dependent. That is, the constant
     <a href="ValueLayout.html#ADDRESS"><code>ValueLayout.ADDRESS</code></a> has a size of 8 bytes on a 64-bit platform;</li>
     <li>The size of a padding layout is always provided explicitly, on
     <a href="#paddingLayout(long)">construction</a>;</li>
     <li>The size of a sequence layout whose element layout is <em>E</em>
     and element count is <em>L</em>, is the size of <em>E</em>,
     multiplied by <em>L</em>;</li>
     <li>The size of a struct layout with member layouts <em>M1</em>, <em>M2</em>, ... <em>Mn</em>
     whose sizes are <em>S1</em>, <em>S2</em>, ... <em>Sn</em>, respectively,
     is <em>S1 + S2 + ... + Sn</em>;</li>
     <li>The size of a union layout <em>U</em> with member layouts
     <em>M1</em>, <em>M2</em>, ... <em>Mn</em> whose sizes are
     <em>S1</em>, <em>S2</em>, ... <em>Sn</em>, respectively, is <em>max(S1, S2, ... Sn).</em></li>
 </ul>
 <p>
 Furthermore, all layouts have a <em>natural alignment</em> (expressed in bytes) which
 is defined as follows:
 <ul>
     <li>The natural alignment of a padding layout is 1;</li>
     <li>The natural alignment of a value layout whose size is <em>N</em> is
     <em>N</em>;</li>
     <li>The natural alignment of a sequence layout whose element layout is
     <em>E</em> is the alignment of <em>E</em>;</li>
     <li>The natural alignment of a group layout with member layouts
     <em>M1</em>, <em>M2</em>, ... <em>Mn</em> whose alignments are
     <em>A1</em>, <em>A2</em>, ... <em>An</em>, respectively, is <em>max(A1, A2 ... An)</em>.</li>
 </ul>
 A layout's alignment can be overridden if needed
 (see <a href="#withByteAlignment(long)"><code>withByteAlignment(long)</code></a>), which can be useful to describe
 layouts with weaker or stronger alignment constraints.

 <h2 id="layout-paths">Layout paths</h2>

 A <em>layout path</em> is used to unambiguously select a layout that is nested in some
 other layout. Layout paths are typically expressed as a sequence of one or more
 <a href="MemoryLayout.PathElement.html" title="interface in java.lang.foreign">path elements</a>. (A more formal definition of layout paths is
 provided <a href="#well-formedness">below</a>).
 <p>
 Layout paths can be used to:
 <ul>
     <li>obtain <a href="#byteOffset(java.lang.foreign.MemoryLayout.PathElement...)">offsets</a> of
     arbitrarily nested layouts;</li>
     <li>obtain a <a href="#varHandle(java.lang.foreign.MemoryLayout.PathElement...)">var handle</a> that can be used
     to access the value corresponding to the selected layout;</li>
     <li><a href="#select(java.lang.foreign.MemoryLayout.PathElement...)">select</a> an arbitrarily nested layout.</li>
 </ul>
 <p>
 For instance, given the <code>taggedValues</code> sequence layout constructed above, we can
 obtain the offset, in bytes, of the member layout named <code>value</code> in the
 <em>first</em> sequence element, as follows:
 
<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="../../../../resource-files/copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-java">long valueOffset = TAGGED_VALUES.byteOffset(PathElement.sequenceElement(0),
                                          PathElement.groupElement("value")); // yields 4
</code></pre>
</div>


 Similarly, we can select the member layout named <code>value</code>, as follows:
 
<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="../../../../resource-files/copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-java">MemoryLayout value = TAGGED_VALUES.select(PathElement.sequenceElement(),
                                         PathElement.groupElement("value"));
</code></pre>
</div>


 <h3 id="open-path-elements">Open path elements</h3>

 Some layout path elements, said <em>open path elements</em>, can select multiple
 layouts at once. For instance, the open path elements
 <a href="MemoryLayout.PathElement.html#sequenceElement()"><code>MemoryLayout.PathElement.sequenceElement()</code></a>, <a href="MemoryLayout.PathElement.html#sequenceElement(long,long)"><code>MemoryLayout.PathElement.sequenceElement(long, long)</code></a>
 select an unspecified element in a sequence layout. A var handle derived from a
 layout path containing one or more open path element features additional coordinates
 of type <code>long</code>, which can be used by clients to <em>bind</em> the open elements
 in the path:

 
<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="../../../../resource-files/copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-java">VarHandle valueHandle = TAGGED_VALUES.varHandle(PathElement.sequenceElement(),
                                               PathElement.groupElement("value"));
MemorySegment taggedValues = ...
// reads the "value" field of the third struct in the array (taggedValues[2].value)
int val = (int) valueHandle.get(taggedValues,
        0L,  // base offset
        2L); // sequence index
</code></pre>
</div>


 <p>
 Open path elements also affect the creation of
 <a href="#byteOffsetHandle(java.lang.foreign.MemoryLayout.PathElement...)">offset-computing method handles</a>. Each
 open path element becomes an additional <code>long</code> parameter in the obtained method
 handle. This parameter can be used to specify the index of the sequence element whose
 offset is to be computed:

 
<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="../../../../resource-files/copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-java">MethodHandle offsetHandle = TAGGED_VALUES.byteOffsetHandle(PathElement.sequenceElement(),
                                                          PathElement.groupElement("kind"));
long offset1 = (long) offsetHandle.invokeExact(0L, 1L); // 0 + (1 * 8) = 8
long offset2 = (long) offsetHandle.invokeExact(0L, 2L); // 0 + (2 * 8) = 16
</code></pre>
</div>


 <h3 id="deref-path-elements">Dereference path elements</h3>

 A special kind of path element, called <em>dereference path element</em>, allows var
 handles obtained from memory layouts to follow pointers. Consider the following layout:

 
<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="../../../../resource-files/copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-java">StructLayout RECTANGLE = MemoryLayout.structLayout(
        ValueLayout.ADDRESS.withTargetLayout(
                MemoryLayout.sequenceLayout(4,
                        MemoryLayout.structLayout(
                                ValueLayout.JAVA_INT.withName("x"),
                                ValueLayout.JAVA_INT.withName("y")
                        ).withName("point")
                 )
         ).withName("points")
);
</code></pre>
</div>


 This layout is a struct layout describing a rectangle. It contains a single field,
 namely <code>points</code>, an address layout whose
 <a href="AddressLayout.html#targetLayout()">target layout</a> is a sequence layout of four
 struct layouts. Each struct layout describes a two-dimensional point, and is defined
 as a pair or <a href="ValueLayout.html#JAVA_INT"><code>ValueLayout.JAVA_INT</code></a> coordinates, with names <code>x</code> and
 <code>y</code>, respectively.
 <p>
 With dereference path elements, we can obtain a var handle that accesses the <code>y</code> coordinate of one of the
 point in the rectangle, as follows:

 
<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="../../../../resource-files/copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-java">VarHandle rectPointYs = RECTANGLE.varHandle(
        PathElement.groupElement("points"),
        PathElement.dereferenceElement(),
        PathElement.sequenceElement(),
        PathElement.groupElement("y")
);

MemorySegment rect = ...
// dereferences the third point struct in the "points" array, and reads its "y" coordinate (rect.points[2]-&gt;y)
int rect_y_2 = (int) rectPointYs.get(rect,
    0L,  // base offset
    2L); // sequence index
</code></pre>
</div>


 <h3 id="well-formedness">Layout path well-formedness</h3>

 A layout path is applied to a layout <code>C_0</code>, also called the
 <em>initial layout</em>. Each path element in a layout path can be thought of as a
 function that updates the current layout <code>C_i-1</code> to some other layout
 <code>C_i</code>. That is, for each path element <code>E1, E2, ... En</code>, in a layout path
 <code>P</code>, we compute <code>C_i = f_i(C_i-1)</code>, where <code>f_i</code> is the selection
 function associated with the path element under consideration, denoted as <code>E_i</code>.
 The final layout <code>C_i</code> is also called the <em>selected layout</em>.
 <p>
 A layout path <code>P</code> is considered well-formed for an initial layout <code>C_0</code>
 if all its path elements <code>E1, E2, ... En</code> are well-formed for their
 corresponding input layouts <code>C_0, C_1, ... C_n-1</code>. A path element <code>E</code> is
 considered well-formed for a layout <code>L</code> if any of the following is true:
 <ul>
 <li><code>L</code> is a sequence layout and <code>E</code> is a sequence path element
 (one of <a href="MemoryLayout.PathElement.html#sequenceElement(long)"><code>MemoryLayout.PathElement.sequenceElement(long)</code></a>, <a href="MemoryLayout.PathElement.html#sequenceElement(long,long)"><code>MemoryLayout.PathElement.sequenceElement(long, long)</code></a>
 or <a href="MemoryLayout.PathElement.html#sequenceElement()"><code>MemoryLayout.PathElement.sequenceElement()</code></a>). Moreover, if <code>E</code> contains one or
 more sequence indices, such indices have to be compatible with the sequence layout's
 element count;</li>
 <li><code>L</code> is a group layout and <code>E</code> is a group path element (one of
 <a href="MemoryLayout.PathElement.html#groupElement(java.lang.String)"><code>MemoryLayout.PathElement.groupElement(String)</code></a> or <a href="MemoryLayout.PathElement.html#groupElement(long)"><code>MemoryLayout.PathElement.groupElement(long)</code></a>).
 Moreover, the group path element must refer to a valid member layout in
 <code>L</code>, either by name, or index;</li>
 <li><code>L</code> is an address layout and <code>E</code> is a <a href="MemoryLayout.PathElement.html#dereferenceElement()">dereference path element</a>.
 Moreover, <code>L</code> must define some <a href="AddressLayout.html#targetLayout()">target layout</a>.</li>
 </ul>
 Any attempt to provide a layout path <code>P</code> that is not well-formed for an initial
 layout <code>C_0</code> will result in an <a href="../IllegalArgumentException.html" title="class in java.lang"><code>IllegalArgumentException</code></a>.

 <h2 id="access-mode-restrictions">Access mode restrictions</h2>

 A var handle returned by <a href="#varHandle(java.lang.foreign.MemoryLayout.PathElement...)"><code>varHandle(PathElement...)</code></a> or
 <a href="ValueLayout.html#varHandle()"><code>ValueLayout.varHandle()</code></a> features certain access characteristics, which are
 derived from the selected layout <code>L</code>:
 <ul>
 <li>A carrier type <code>T</code>, derived from <code>L.carrier()</code></li>
 <li>An alignment constraint <code>A</code>, derived from <code>L.byteAlignment()</code></li>
 <li>An access size <code>S</code>, derived from <code>L.byteSize()</code></li>
 </ul>
 Depending on the above characteristics, the returned var handle might feature certain
 <i>access mode restrictions</i>. We say that a var handle is <em>aligned</em> if its
 alignment constraint <code>A</code> is compatible with the access size <code>S</code>, that is
 if <code>A &gt;= S</code>. An aligned var handle is guaranteed to support the following
 access modes:
 <ul>
 <li>read write access modes for all <code>T</code>. On 32-bit platforms, access modes
     <code>get</code> and <code>set</code> for <code>long</code>, <code>double</code> and <code>MemorySegment</code>
     are supported but might lead to word tearing, as described in Section <a href="https://docs.oracle.com/javase/specs/jls/se22/html/jls-17.html#jls-17.7">17.7</a>.
     of <cite>The Java Language Specification</cite>.
 <li>atomic update access modes for <code>int</code>, <code>long</code>,
     <code>float</code>, <code>double</code> and <a href="MemorySegment.html" title="interface in java.lang.foreign"><code>MemorySegment</code></a>.
     (Future major platform releases of the JDK may support additional
     types for certain currently unsupported access modes.)
 <li>numeric atomic update access modes for <code>int</code>, <code>long</code> and <a href="MemorySegment.html" title="interface in java.lang.foreign"><code>MemorySegment</code></a>.
     (Future major platform releases of the JDK may support additional
     numeric types for certain currently unsupported access modes.)
 <li>bitwise atomic update access modes for <code>int</code>, <code>long</code> and <a href="MemorySegment.html" title="interface in java.lang.foreign"><code>MemorySegment</code></a>.
     (Future major platform releases of the JDK may support additional
     numeric types for certain currently unsupported access modes.)
 </ul>
 If <code>T</code> is <code>float</code>, <code>double</code> or <a href="MemorySegment.html" title="interface in java.lang.foreign"><code>MemorySegment</code></a> then atomic
 update access modes compare values using their bitwise representation
 (see <a href="../Float.html#floatToRawIntBits(float)"><code>Float.floatToRawIntBits(float)</code></a>, <a href="../Double.html#doubleToRawLongBits(double)"><code>Double.doubleToRawLongBits(double)</code></a>
 and <a href="MemorySegment.html#address()"><code>MemorySegment.address()</code></a>, respectively).
 <p>
 Alternatively, a var handle is <em>unaligned</em> if its alignment constraint <code>A</code>
 is incompatible with the access size <code>S</code>, that is, if <code>A &lt; S</code>. An
 unaligned var handle only supports the <code>get</code> and <code>set</code> access modes. All
 other access modes will result in <a href="../UnsupportedOperationException.html" title="class in java.lang"><code>UnsupportedOperationException</code></a> being thrown.
 Moreover, while supported, access modes <code>get</code> and <code>set</code> might lead to
 word tearing.

 <h2 id="variable-length">Working with variable-length arrays</h2>

 We have seen how sequence layouts are used to describe the contents of an array whose
 size is known <em>statically</em>. There are cases, however, where the array size is
 only known <em>dynamically</em>. We call such arrays <em>variable-length arrays</em>.
 There are two common kinds of variable-length arrays:
 <ul>
     <li>a <em>toplevel</em> variable-length array whose size depends on the value of
     some unrelated variable, or parameter;</li>
     <li>an variable-length array <em>nested</em> in a struct, whose size depends on
     the value of some other field in the enclosing struct.</li>
 </ul>
 While variable-length arrays cannot be modeled directly using sequence layouts,
 clients can still enjoy structured access to elements of variable-length arrays
 using var handles as demonstrated in the following sections.

 <h3 id="variable-length-toplevel">Toplevel variable-length arrays</h3>

 Consider the following struct declaration in C:

 
<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="../../../../resource-files/copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-c">typedef struct {
    int x;
    int y;
} Point;
</code></pre>
</div>


 In the above code, a point is modeled as two coordinates (<code>x</code> and
 <code>y</code> respectively). Now consider the following snippet of C code:

 
<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="../../../../resource-files/copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-c">int size = ...
Point *points = (Point*)malloc(sizeof(Point) * size);
for (int i = 0 ; i &lt; size ; i++) {
   ... points[i].x ...
}
</code></pre>
</div>


 Here, we allocate an array of points (<code>points</code>). Crucially, the size of
 the array is dynamically bound to the value of the <code>size</code> variable. Inside
 the loop, the <code>x</code> coordinate of all the points in the array is accessed.
 <p>
 To model this code in Java, let's start by defining a layout for the <code>Point</code>
 struct, as follows:

 
<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="../../../../resource-files/copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-java">StructLayout POINT = MemoryLayout.structLayout(
            ValueLayout.JAVA_INT.withName("x"),
            ValueLayout.JAVA_INT.withName("y")
);
</code></pre>
</div>


 Since we know we need to create and access an array of points, it would be tempting to
 create a sequence layout modelling the variable-length array, and then derive the
 necessary access var handles from the sequence layout. But this approach is
 problematic, as the size of the variable-length array is not known. Instead, a
 var handle that provides structured access to the elements of a variable-length array
 can be obtained directly from the layout describing the array elements
 (e.g. the point layout), as demonstrated below:

 
<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="../../../../resource-files/copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-java">VarHandle POINT_ARR_X = POINT.arrayElementVarHandle(PathElement.groupElement("x"));

int size = ...
MemorySegment points = ...
for (int i = 0 ; i &lt; size ; i++) {
    ... POINT_ARR_X.get(segment, 0L, (long)i) ...
}
</code></pre>
</div>


 Here, the coordinate <code>x</code> of subsequent point in the array is accessed using the
 <code>POINT_ARR_X</code> var handle, which is obtained using the
 <a href="#arrayElementVarHandle(java.lang.foreign.MemoryLayout.PathElement...)"><code>arrayElementVarHandle(PathElement...)</code></a> method. This var handle features two
 <code>long</code> coordinates: the first is a base offset (set to <code>0L</code>), while the
 second is a logical index that can be used to stride over all the elements of the
 point array.
 <p>
 The base offset coordinate allows clients to express complex access operations, by
 injecting additional offset computation into the var handle (we will see an example
 of that below). In cases where the base offset is constant (as in the previous
 example) clients can, if desired, drop the base offset parameter and make the access
 expression simpler. This is achieved using the
 <a href="../invoke/MethodHandles.html#insertCoordinates(java.lang.invoke.VarHandle,int,java.lang.Object...)"><code>MethodHandles.insertCoordinates(VarHandle, int, Object...)</code></a>
 var handle adapter.

 <h3 id="variable-length-nested">Nested variable-length arrays</h3>

 Consider the following struct declaration in C:

 
<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="../../../../resource-files/copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-c">typedef struct {
    int size;
    Point points[];
} Polygon;
</code></pre>
</div>


 In the above code, a polygon is modeled as a size (the number of edges in the polygon)
 and an array of points (one for each vertex in the polygon). The number of vertices
 depends on the number of edges in the polygon. As such, the size of the <code>points</code>
 array is left <em>unspecified</em> in the C declaration, using a
 <em>Flexible Array Member</em> (a feature standardized in C99).
 <p>
 Again, clients can perform structured access to elements in the nested variable-length
 array using the <a href="#arrayElementVarHandle(java.lang.foreign.MemoryLayout.PathElement...)"><code>arrayElementVarHandle(PathElement...)</code></a> method, as demonstrated
 below:

 
<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="../../../../resource-files/copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-java">StructLayout POLYGON = MemoryLayout.structLayout(
            ValueLayout.JAVA_INT.withName("size"),
            MemoryLayout.sequenceLayout(0, POINT).withName("points")
);

VarHandle POLYGON_SIZE = POLYGON.varHandle(0, PathElement.groupElement("size"));
long POINTS_OFFSET = POLYGON.byteOffset(PathElement.groupElement("points"));
</code></pre>
</div>


 The <code>POLYGON</code> layout contains a sequence layout of size <em>zero</em>. The
 element layout of the sequence layout is the <code>POINT</code> layout, shown previously.
 The polygon layout is used to obtain a var handle that provides access to the polygon
 size, as well as an offset (<code>POINTS_OFFSET</code>) to the start of the variable-length
 <code>points</code> array.
 <p>
 The <code>x</code> coordinates of all the points in a polygon can then be accessed as
 follows:
 
<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="../../../../resource-files/copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-java">MemorySegment polygon = ...
int size = POLYGON_SIZE.get(polygon, 0L);
for (int i = 0 ; i &lt; size ; i++) {
    ... POINT_ARR_X.get(polygon, POINTS_OFFSET, (long)i) ...
}
</code></pre>
</div>

 Here, we first obtain the polygon size, using the <code>POLYGON_SIZE</code> var handle.
 Then, in a loop, we read the <code>x</code> coordinates of all the points in the polygon.
 This is done by providing a custom offset (namely, <code>POINTS_OFFSET</code>) to the
 offset coordinate of the <code>POINT_ARR_X</code> var handle. As before, the loop
 induction variable <code>i</code> is passed as the index of the <code>POINT_ARR_X</code>
 var handle, to stride over all the elements of the variable-length array.</div>
<dl class="notes">
<dt>Implementation Requirements:</dt>
<dd>Implementations of this interface are immutable, thread-safe and
 <a href="../../../../java.base/java/lang/doc-files/ValueBased.html">value-based</a>.</dd>
<dt>Sealed Class Hierarchy Graph:</dt><dd><a class="sealed-graph" href="MemoryLayout-sealed-graph.svg"><img style="vertical-align:top" alt="Sealed class hierarchy graph for MemoryLayout" src="MemoryLayout-sealed-graph.svg" height="100"><span><img style="border: solid lightgray 1px; vertical-align:top" alt="Sealed class hierarchy graph for MemoryLayout" src="MemoryLayout-sealed-graph.svg"></span></a></dd>
<dt>Since:</dt>
<dd>22</dd>
</dl>
</div>
</section>
<section class="summary">
<ul class="summary-list">
<!-- ======== NESTED CLASS SUMMARY ======== -->
<li>
<section class="nested-class-summary" id="nested-class-summary">
<h2>Nested Class Summary</h2>
<div class="caption"><span>Nested Classes</span></div>
<div class="summary-table three-column-summary">
<div class="table-header col-first">Modifier and Type</div>
<div class="table-header col-second">Interface</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color"><code>static interface&nbsp;</code></div>
<div class="col-second even-row-color"><code><a href="MemoryLayout.PathElement.html" class="type-name-link" title="interface in java.lang.foreign">MemoryLayout.PathElement</a></code></div>
<div class="col-last even-row-color">
<div class="block">An element in a <a href="MemoryLayout.html#layout-paths"><em>layout path</em></a>.</div>
</div>
</div>
</section>
</li>
<!-- ========== METHOD SUMMARY =========== -->
<li>
<section class="method-summary" id="method-summary">
<h2>Method Summary</h2>
<div id="method-summary-table">
<div class="table-tabs" role="tablist" aria-orientation="horizontal"><button id="method-summary-table-tab0" role="tab" aria-selected="true" aria-controls="method-summary-table.tabpanel" tabindex="0" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table', 3)" class="active-table-tab">All Methods</button><button id="method-summary-table-tab1" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab1', 3)" class="table-tab">Static Methods</button><button id="method-summary-table-tab2" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab2', 3)" class="table-tab">Instance Methods</button><button id="method-summary-table-tab3" role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" onclick="show('method-summary-table', 'method-summary-table-tab3', 3)" class="table-tab">Abstract Methods</button></div>
<div id="method-summary-table.tabpanel" role="tabpanel">
<div class="summary-table three-column-summary" aria-labelledby="method-summary-table-tab0">
<div class="table-header col-first">Modifier and Type</div>
<div class="table-header col-second">Method</div>
<div class="table-header col-last">Description</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="../invoke/VarHandle.html" title="class in java.lang.invoke">VarHandle</a></code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#arrayElementVarHandle(java.lang.foreign.MemoryLayout.PathElement...)" class="member-name-link">arrayElementVarHandle</a><wbr>(<a href="MemoryLayout.PathElement.html" title="interface in java.lang.foreign">MemoryLayout.PathElement</a>...&nbsp;elements)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Creates a var handle that accesses adjacent elements in a memory segment at
 offsets selected by the given layout path, where the accessed elements have this
 layout, and where the initial layout in the path is this layout.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>long</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#byteAlignment()" class="member-name-link">byteAlignment</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Returns the alignment constraint associated with this layout, expressed in bytes.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>long</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#byteOffset(java.lang.foreign.MemoryLayout.PathElement...)" class="member-name-link">byteOffset</a><wbr>(<a href="MemoryLayout.PathElement.html" title="interface in java.lang.foreign">MemoryLayout.PathElement</a>...&nbsp;elements)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Computes the offset, in bytes, of the layout selected by the given layout path,
 where the initial layout in the path is this layout.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="../invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#byteOffsetHandle(java.lang.foreign.MemoryLayout.PathElement...)" class="member-name-link">byteOffsetHandle</a><wbr>(<a href="MemoryLayout.PathElement.html" title="interface in java.lang.foreign">MemoryLayout.PathElement</a>...&nbsp;elements)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Creates a method handle that computes the offset, in bytes, of the layout selected
 by the given layout path, where the initial layout in the path is this layout.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>long</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#byteSize()" class="member-name-link">byteSize</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Returns the layout size, in bytes.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>boolean</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#equals(java.lang.Object)" class="member-name-link">equals</a><wbr>(<a href="../Object.html" title="class in java.lang">Object</a>&nbsp;other)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Compares the specified object with this layout for equality.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>int</code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#hashCode()" class="member-name-link">hashCode</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Returns the hash code value for this layout.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="../../util/Optional.html" title="class in java.util">Optional</a><wbr>&lt;<a href="../String.html" title="class in java.lang">String</a>&gt;</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#name()" class="member-name-link">name</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Returns the name (if any) associated with this layout.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1"><code>static <a href="PaddingLayout.html" title="interface in java.lang.foreign">PaddingLayout</a></code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1"><code><a href="#paddingLayout(long)" class="member-name-link">paddingLayout</a><wbr>(long&nbsp;byteSize)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1">
<div class="block">Creates a padding layout with the given byte size.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code>long</code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#scale(long,long)" class="member-name-link">scale</a><wbr>(long&nbsp;offset,
 long&nbsp;index)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Returns <code>offset + (byteSize() * index)</code>.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="../invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#scaleHandle()" class="member-name-link">scaleHandle</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Returns a method handle that can be used to invoke <a href="#scale(long,long)"><code>scale(long, long)</code></a>
         on this layout.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="MemoryLayout.html" title="interface in java.lang.foreign">MemoryLayout</a></code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#select(java.lang.foreign.MemoryLayout.PathElement...)" class="member-name-link">select</a><wbr>(<a href="MemoryLayout.PathElement.html" title="interface in java.lang.foreign">MemoryLayout.PathElement</a>...&nbsp;elements)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Returns the layout selected from the provided path, where the initial layout in
 the path is this layout.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1"><code>static <a href="SequenceLayout.html" title="interface in java.lang.foreign">SequenceLayout</a></code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1"><code><a href="#sequenceLayout(long,java.lang.foreign.MemoryLayout)" class="member-name-link">sequenceLayout</a><wbr>(long&nbsp;elementCount,
 <a href="MemoryLayout.html" title="interface in java.lang.foreign">MemoryLayout</a>&nbsp;elementLayout)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1">
<div class="block">Creates a sequence layout with the given element layout and element count.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="../invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#sliceHandle(java.lang.foreign.MemoryLayout.PathElement...)" class="member-name-link">sliceHandle</a><wbr>(<a href="MemoryLayout.PathElement.html" title="interface in java.lang.foreign">MemoryLayout.PathElement</a>...&nbsp;elements)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Creates a method handle which, given a memory segment, returns a
 <a href="MemorySegment.html#asSlice(long,long)">slice</a> corresponding to
 the layout selected by the given layout path, where the initial layout in
 the path is this layout.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1"><code>static <a href="StructLayout.html" title="interface in java.lang.foreign">StructLayout</a></code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1"><code><a href="#structLayout(java.lang.foreign.MemoryLayout...)" class="member-name-link">structLayout</a><wbr>(<a href="MemoryLayout.html" title="interface in java.lang.foreign">MemoryLayout</a>...&nbsp;elements)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1">
<div class="block">Creates a struct layout with the given member layouts.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="../String.html" title="class in java.lang">String</a></code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#toString()" class="member-name-link">toString</a>()</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Returns the string representation of this layout.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab1"><code>static <a href="UnionLayout.html" title="interface in java.lang.foreign">UnionLayout</a></code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab1"><code><a href="#unionLayout(java.lang.foreign.MemoryLayout...)" class="member-name-link">unionLayout</a><wbr>(<a href="MemoryLayout.html" title="interface in java.lang.foreign">MemoryLayout</a>...&nbsp;elements)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab1">
<div class="block">Creates a union layout with the given member layouts.</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="../invoke/VarHandle.html" title="class in java.lang.invoke">VarHandle</a></code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#varHandle(java.lang.foreign.MemoryLayout.PathElement...)" class="member-name-link">varHandle</a><wbr>(<a href="MemoryLayout.PathElement.html" title="interface in java.lang.foreign">MemoryLayout.PathElement</a>...&nbsp;elements)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Creates a var handle that accesses a memory segment at the offset selected by the
 given layout path, where the initial layout in the path is this layout.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="MemoryLayout.html" title="interface in java.lang.foreign">MemoryLayout</a></code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#withByteAlignment(long)" class="member-name-link">withByteAlignment</a><wbr>(long&nbsp;byteAlignment)</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Returns a memory layout with the same characteristics as this layout, but with
          the given alignment constraint (in bytes).</div>
</div>
<div class="col-first odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="MemoryLayout.html" title="interface in java.lang.foreign">MemoryLayout</a></code></div>
<div class="col-second odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#withName(java.lang.String)" class="member-name-link">withName</a><wbr>(<a href="../String.html" title="class in java.lang">String</a>&nbsp;name)</code></div>
<div class="col-last odd-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Returns a memory layout with the same characteristics as this layout, but with
          the given name.</div>
</div>
<div class="col-first even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="MemoryLayout.html" title="interface in java.lang.foreign">MemoryLayout</a></code></div>
<div class="col-second even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3"><code><a href="#withoutName()" class="member-name-link">withoutName</a>()</code></div>
<div class="col-last even-row-color method-summary-table method-summary-table-tab2 method-summary-table-tab3">
<div class="block">Returns a memory layout with the same characteristics as this layout, but with
          no name.</div>
</div>
</div>
</div>
</div>
</section>
</li>
</ul>
</section>
<section class="details">
<ul class="details-list">
<!-- ============ METHOD DETAIL ========== -->
<li>
<section class="method-details" id="method-detail">
<h2>Method Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="byteSize()">
<h3>byteSize</h3>
<div class="horizontal-scroll">
<div class="member-signature"><span class="return-type">long</span>&nbsp;<span class="element-name">byteSize</span>()</div>
<div class="block">Returns the layout size, in bytes.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>the layout size, in bytes</dd>
</dl>
</div>
</section>
</li>
<li>
<section class="detail" id="name()">
<h3>name</h3>
<div class="horizontal-scroll">
<div class="member-signature"><span class="return-type"><a href="../../util/Optional.html" title="class in java.util">Optional</a>&lt;<a href="../String.html" title="class in java.lang">String</a>&gt;</span>&nbsp;<span class="element-name">name</span>()</div>
<div class="block">Returns the name (if any) associated with this layout.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>the name (if any) associated with this layout</dd>
<dt>See Also:</dt>
<dd>
<ul class="tag-list">
<li><a href="#withName(java.lang.String)"><code>withName(String)</code></a></li>
</ul>
</dd>
</dl>
</div>
</section>
</li>
<li>
<section class="detail" id="withName(java.lang.String)">
<h3>withName</h3>
<div class="horizontal-scroll">
<div class="member-signature"><span class="return-type"><a href="MemoryLayout.html" title="interface in java.lang.foreign">MemoryLayout</a></span>&nbsp;<span class="element-name">withName</span><wbr><span class="parameters">(<a href="../String.html" title="class in java.lang">String</a>&nbsp;name)</span></div>
<div class="block">Returns a memory layout with the same characteristics as this layout, but with
          the given name.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>name</code> - the layout name</dd>
<dt>Returns:</dt>
<dd>a memory layout with the same characteristics as this layout, but with
          the given name</dd>
<dt>See Also:</dt>
<dd>
<ul class="tag-list">
<li><a href="#name()"><code>name()</code></a></li>
</ul>
</dd>
</dl>
</div>
</section>
</li>
<li>
<section class="detail" id="withoutName()">
<h3>withoutName</h3>
<div class="horizontal-scroll">
<div class="member-signature"><span class="return-type"><a href="MemoryLayout.html" title="interface in java.lang.foreign">MemoryLayout</a></span>&nbsp;<span class="element-name">withoutName</span>()</div>
<div class="block">Returns a memory layout with the same characteristics as this layout, but with
          no name.</div>
<dl class="notes">
<dt>API Note:</dt>
<dd>This can be useful to compare two layouts that have different names, but
          are otherwise equal.</dd>
<dt>Returns:</dt>
<dd>a memory layout with the same characteristics as this layout, but with
          no name</dd>
<dt>See Also:</dt>
<dd>
<ul class="tag-list">
<li><a href="#name()"><code>name()</code></a></li>
</ul>
</dd>
</dl>
</div>
</section>
</li>
<li>
<section class="detail" id="byteAlignment()">
<h3>byteAlignment</h3>
<div class="horizontal-scroll">
<div class="member-signature"><span class="return-type">long</span>&nbsp;<span class="element-name">byteAlignment</span>()</div>
<div class="block">Returns the alignment constraint associated with this layout, expressed in bytes.
 <p>
 Layout alignment defines a power of two <code>A</code> which is the byte-wise alignment
 of the layout, where <code>A</code> is the number of bytes that must be aligned for any
 pointer that correctly points to this layout. Thus:

 <ul>
 <li><code>A=1</code> means unaligned (in the usual sense), which is common in packets.</li>
 <li><code>A=8</code> means word aligned (on LP64), <code>A=4</code> int aligned,
 <code>A=2</code> short aligned, etc.</li>
 <li><code>A=64</code> is the most strict alignment required by the x86/SV ABI
 (for AVX-512 data).</li>
 </ul>

 If no explicit alignment constraint was set on this layout (
 see <a href="#withByteAlignment(long)"><code>withByteAlignment(long)</code></a>), then this method returns the
 <a href="#layout-align">natural alignment</a> constraint (in bytes) associated
 with this layout.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>the alignment constraint associated with this layout, expressed in bytes</dd>
</dl>
</div>
</section>
</li>
<li>
<section class="detail" id="withByteAlignment(long)">
<h3>withByteAlignment</h3>
<div class="horizontal-scroll">
<div class="member-signature"><span class="return-type"><a href="MemoryLayout.html" title="interface in java.lang.foreign">MemoryLayout</a></span>&nbsp;<span class="element-name">withByteAlignment</span><wbr><span class="parameters">(long&nbsp;byteAlignment)</span></div>
<div class="block">Returns a memory layout with the same characteristics as this layout, but with
          the given alignment constraint (in bytes).</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>byteAlignment</code> - the layout alignment constraint, expressed in bytes</dd>
<dt>Returns:</dt>
<dd>a memory layout with the same characteristics as this layout, but with
          the given alignment constraint (in bytes)</dd>
<dt>Throws:</dt>
<dd><code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if <code>byteAlignment</code> is not a power of two</dd>
</dl>
</div>
</section>
</li>
<li>
<section class="detail" id="scale(long,long)">
<h3>scale</h3>
<div class="horizontal-scroll">
<div class="member-signature"><span class="return-type">long</span>&nbsp;<span class="element-name">scale</span><wbr><span class="parameters">(long&nbsp;offset,
 long&nbsp;index)</span></div>
<div class="block">Returns <code>offset + (byteSize() * index)</code>.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>offset</code> - the base offset</dd>
<dd><code>index</code> - the index to be scaled by the byte size of this layout</dd>
<dt>Returns:</dt>
<dd><code>offset + (byteSize() * index)</code></dd>
<dt>Throws:</dt>
<dd><code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if <code>offset</code> or <code>index</code> is negative</dd>
<dd><code><a href="../ArithmeticException.html" title="class in java.lang">ArithmeticException</a></code> - if either the addition or multiplication overflows</dd>
</dl>
</div>
</section>
</li>
<li>
<section class="detail" id="scaleHandle()">
<h3>scaleHandle</h3>
<div class="horizontal-scroll">
<div class="member-signature"><span class="return-type"><a href="../invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></span>&nbsp;<span class="element-name">scaleHandle</span>()</div>
<div class="block">Returns a method handle that can be used to invoke <a href="#scale(long,long)"><code>scale(long, long)</code></a>
         on this layout.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>a method handle that can be used to invoke <a href="#scale(long,long)"><code>scale(long, long)</code></a>
         on this layout</dd>
</dl>
</div>
</section>
</li>
<li>
<section class="detail" id="byteOffset(java.lang.foreign.MemoryLayout.PathElement...)">
<h3>byteOffset</h3>
<div class="horizontal-scroll">
<div class="member-signature"><span class="return-type">long</span>&nbsp;<span class="element-name">byteOffset</span><wbr><span class="parameters">(<a href="MemoryLayout.PathElement.html" title="interface in java.lang.foreign">MemoryLayout.PathElement</a>...&nbsp;elements)</span></div>
<div class="block">Computes the offset, in bytes, of the layout selected by the given layout path,
 where the initial layout in the path is this layout.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>elements</code> - the layout path elements</dd>
<dt>Returns:</dt>
<dd>The offset, in bytes, of the layout selected by the layout path in
         <code>elements</code></dd>
<dt>Throws:</dt>
<dd><code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if the layout path is not
         <a href="#well-formedness">well-formed</a> for this layout</dd>
<dd><code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if the layout path contains one or more
         <a href=#open-path-elements>open path elements</a></dd>
<dd><code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if the layout path contains one or more
         <a href=#deref-path-elements>dereference path elements</a></dd>
</dl>
</div>
</section>
</li>
<li>
<section class="detail" id="byteOffsetHandle(java.lang.foreign.MemoryLayout.PathElement...)">
<h3>byteOffsetHandle</h3>
<div class="horizontal-scroll">
<div class="member-signature"><span class="return-type"><a href="../invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></span>&nbsp;<span class="element-name">byteOffsetHandle</span><wbr><span class="parameters">(<a href="MemoryLayout.PathElement.html" title="interface in java.lang.foreign">MemoryLayout.PathElement</a>...&nbsp;elements)</span></div>
<div class="block">Creates a method handle that computes the offset, in bytes, of the layout selected
 by the given layout path, where the initial layout in the path is this layout.
 <p>
 The returned method handle has the following characteristics:
 <ul>
     <li>its return type is <code>long</code>;</li>
     <li>it has one leading <code>long</code> parameter representing the base offset;</li>
     <li>it has as zero or more trailing parameters of type <code>long</code>, one for
     each <a href=#open-path-elements>open path element</a> in the provided layout
     path. The order of these parameters corresponds to the order in which the
     open path elements occur in the provided layout path.
 </ul>
 <p>
 The final offset returned by the method handle is computed as follows:

 <blockquote><pre><code>
 offset = b + c_1 + c_2 + ... + c_m + (x_1 * s_1) + (x_2 * s_2) + ... + (x_n * s_n)
 </code></pre></blockquote>

 where <code>b</code> represents the base offset provided as a <em>dynamic</em>
 <code>long</code> argument, <code>x_1</code>, <code>x_2</code>, ... <code>x_n</code> represent indices
 into sequences provided as <em>dynamic</em> <code>long</code> arguments, whereas
 <code>s_1</code>, <code>s_2</code>, ... <code>s_n</code> are <em>static</em> stride constants
 derived from the size of the element layout of a sequence, and
 <code>c_1</code>, <code>c_2</code>, ... <code>c_m</code> are other <em>static</em> offset
 constants (such as field offsets) which are derived from the layout path.</div>
<dl class="notes">
<dt>API Note:</dt>
<dd>The returned method handle can be used to compute a layout offset,
          similarly to <a href="#byteOffset(java.lang.foreign.MemoryLayout.PathElement...)"><code>byteOffset(PathElement...)</code></a>, but more flexibly, as
          some indices can be specified when invoking the method handle.</dd>
<dt>Parameters:</dt>
<dd><code>elements</code> - the layout path elements</dd>
<dt>Returns:</dt>
<dd>a method handle that computes the offset, in bytes, of the layout selected
         by the given layout path</dd>
<dt>Throws:</dt>
<dd><code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if the layout path is not
         <a href="#well-formedness">well-formed</a> for this layout</dd>
<dd><code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if the layout path contains one or more
         <a href=#deref-path-elements>dereference path elements</a></dd>
</dl>
</div>
</section>
</li>
<li>
<section class="detail" id="varHandle(java.lang.foreign.MemoryLayout.PathElement...)">
<h3>varHandle</h3>
<div class="horizontal-scroll">
<div class="member-signature"><span class="return-type"><a href="../invoke/VarHandle.html" title="class in java.lang.invoke">VarHandle</a></span>&nbsp;<span class="element-name">varHandle</span><wbr><span class="parameters">(<a href="MemoryLayout.PathElement.html" title="interface in java.lang.foreign">MemoryLayout.PathElement</a>...&nbsp;elements)</span></div>
<div class="block">Creates a var handle that accesses a memory segment at the offset selected by the
 given layout path, where the initial layout in the path is this layout.
 <p>
 The returned var handle has the following characteristics:
 <ul>
     <li>its type is derived from the <a href="ValueLayout.html#carrier()">carrier</a> of the
     selected value layout;</li>
     <li>it has a leading parameter of type <code>MemorySegment</code> representing the
     accessed segment</li>
     <li>a following <code>long</code> parameter, corresponding to the base offset,
     denoted as <code>B</code>;</li>
     <li>it has zero or more trailing access coordinates of type <code>long</code>,
     one for each <a href=#open-path-elements>open path element</a> in the provided
     layout path, denoted as <code>I1, I2, ... In</code>, respectively. The order of
     these access coordinates corresponds to the order in which the open path
     elements occur in the provided layout path.
 </ul>
 <p>
 If the provided layout path <code>P</code> contains no dereference elements, then the
 offset <code>O</code> of the access operation is computed as follows:

 
<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="../../../../resource-files/copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-java">O = this.offsetHandle(P).invokeExact(B, I1, I2, ... In);
</code></pre>
</div>

 <p>
 Accessing a memory segment using the var handle returned by this method is subject
 to the following checks:
 <ul>
     <li>The physical address of the accessed memory segment must be
     <a href="MemorySegment.html#segment-alignment">aligned</a> according to the
     <a href="#byteAlignment()">alignment constraint</a> of the root layout
     (this layout), or an <a href="../IllegalArgumentException.html" title="class in java.lang"><code>IllegalArgumentException</code></a> is thrown. Note
     that the alignment constraint of the root layout can be more strict
     (but not less) than the alignment constraint of the selected value layout.</li>
     <li>The offset of the access operation (computed as above) must fall inside
     the spatial bounds of the accessed memory segment, or an
     <a href="../IndexOutOfBoundsException.html" title="class in java.lang"><code>IndexOutOfBoundsException</code></a> is thrown. This is the case when
     <code>O + A &lt;= S</code>, where <code>O</code> is the accessed offset (computed as above),
     <code>A</code> is the size of the selected layout and <code>S</code> is the size of the
     accessed memory segment.</li>
     <li>The accessed memory segment must be
     <a href="MemorySegment.html#isAccessibleBy(java.lang.Thread)"><code>accessible</code></a> from the thread
     performing the access operation, or a <a href="../WrongThreadException.html" title="class in java.lang"><code>WrongThreadException</code></a> is thrown.</li>
     <li>For write operations, the accessed memory segment must not be
     <a href="MemorySegment.html#isReadOnly()"><code>read only</code></a>, or an
     <a href="../IllegalArgumentException.html" title="class in java.lang"><code>IllegalArgumentException</code></a> is thrown.</li>
     <li>The <a href="MemorySegment.html#scope()">scope</a> associated with the accessed
     segment must be <a href="MemorySegment.Scope.html#isAlive()">alive</a>, or an
     <a href="../IllegalStateException.html" title="class in java.lang"><code>IllegalStateException</code></a> is thrown.</li>
 </ul>
 <p>
 If the selected layout is an <a href="AddressLayout.html" title="interface in java.lang.foreign">address layout</a>, calling
 <a href="../invoke/VarHandle.html#get(java.lang.Object...)"><code>VarHandle.get(Object...)</code></a> on the returned var handle will return a new
 memory segment. The segment is associated with the global scope. Moreover, the
 size of the segment depends on whether the address layout has a
 <a href="AddressLayout.html#targetLayout()">target layout</a>. More specifically:
 <ul>
     <li>If the address layout has a target layout <code>T</code>, then the size
     of the returned segment is <code>T.byteSize()</code>;</li>
     <li>Otherwise, the address layout has no target layout and the size
     of the returned segment
     is <a href="MemorySegment.html#wrapping-addresses">zero</a>.</li>
 </ul>
 Moreover, if the selected layout is an <a href="AddressLayout.html" title="interface in java.lang.foreign">address layout</a>,
 calling <a href="../invoke/VarHandle.html#set(java.lang.Object...)"><code>VarHandle.set(Object...)</code></a> can throw <a href="../IllegalArgumentException.html" title="class in java.lang"><code>IllegalArgumentException</code></a>
 if the memory segment representing the address to be written is not a
 <a href="MemorySegment.html#isNative()">native</a> memory segment.
 <p>
 If the provided layout path has size <code>m</code> and contains a dereference path
 element in position <code>k</code> (where <code>k &lt;= m</code>) then two layout paths
 <code>P</code> and <code>P'</code> are derived, where P contains all the path elements from
 0 to <code>k - 1</code> and <code>P'</code> contains all the path elements from <code>k + 1</code>
 to <code>m</code> (if any). Then, the returned var handle is computed as follows:

 
<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="../../../../resource-files/copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-java">VarHandle baseHandle = this.varHandle(P);
MemoryLayout target = ((AddressLayout)this.select(P)).targetLayout().get();
VarHandle targetHandle = target.varHandle(P);
targetHandle = MethodHandles.insertCoordinates(targetHandle, 1, 0L); // always access nested targets at offset 0
targetHandle = MethodHandles.collectCoordinates(targetHandle, 0,
        baseHandle.toMethodHandle(VarHandle.AccessMode.GET));
</code></pre>
</div>


 (The above can be trivially generalized to cases where the provided layout path
 contains more than one dereference path elements).
 <p>
 As an example, consider the memory layout expressed by a <a href="GroupLayout.html" title="interface in java.lang.foreign"><code>GroupLayout</code></a>
 instance constructed as follows:
 
<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="../../../../resource-files/copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-java">    GroupLayout grp = java.lang.foreign.MemoryLayout.structLayout(
            MemoryLayout.paddingLayout(4),
            ValueLayout.JAVA_INT.withOrder(ByteOrder.BIG_ENDIAN).withName("value")
    );
</code></pre>
</div>

 To access the member layout named <code>value</code>, we can construct a var handle as
 follows:
 
<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="../../../../resource-files/copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-java">    VarHandle handle = grp.varHandle(PathElement.groupElement("value")); //(MemorySegment, long) -&gt; int
</code></pre>
</div>
</div>
<dl class="notes">
<dt>API Note:</dt>
<dd>The resulting var handle features certain
 <a href="#access-mode-restrictions"><em>access mode restrictions</em></a>, which
 are common to all var handles derived from memory layouts.</dd>
<dt>Parameters:</dt>
<dd><code>elements</code> - the layout path elements</dd>
<dt>Returns:</dt>
<dd>a var handle that accesses a memory segment at the offset selected by the
         given layout path</dd>
<dt>Throws:</dt>
<dd><code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if the layout path is not
         <a href="#well-formedness">well-formed</a> for this layout</dd>
<dd><code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if the layout selected by the provided path is not a
         <a href="ValueLayout.html" title="interface in java.lang.foreign">value layout</a></dd>
</dl>
</div>
</section>
</li>
<li>
<section class="detail" id="arrayElementVarHandle(java.lang.foreign.MemoryLayout.PathElement...)">
<h3>arrayElementVarHandle</h3>
<div class="horizontal-scroll">
<div class="member-signature"><span class="return-type"><a href="../invoke/VarHandle.html" title="class in java.lang.invoke">VarHandle</a></span>&nbsp;<span class="element-name">arrayElementVarHandle</span><wbr><span class="parameters">(<a href="MemoryLayout.PathElement.html" title="interface in java.lang.foreign">MemoryLayout.PathElement</a>...&nbsp;elements)</span></div>
<div class="block">Creates a var handle that accesses adjacent elements in a memory segment at
 offsets selected by the given layout path, where the accessed elements have this
 layout, and where the initial layout in the path is this layout.
 <p>
 The returned var handle has the following characteristics:
 <ul>
     <li>its type is derived from the <a href="ValueLayout.html#carrier()">carrier</a> of the
     selected value layout;</li>
     <li>it has a leading parameter of type <code>MemorySegment</code> representing
     the accessed segment</li>
     <li>a following <code>long</code> parameter, corresponding to the base offset,
     denoted as <code>B</code>;</li>
     <li>a following <code>long</code> parameter, corresponding to the array index,
     denoted as <code>I0</code>. The array index is used to scale the accessed offset
     by this layout size;</li>
     <li>it has zero or more trailing access coordinates of type <code>long</code>,
     one for each <a href=#open-path-elements>open path element</a> in the provided
     layout path, denoted as <code>I1, I2, ... In</code>, respectively. The order of
     these access coordinates corresponds to the order in which the open path
     elements occur in the provided layout path.
 </ul>
 <p>
 If the provided layout path <code>P</code> contains no dereference elements, then the
 offset <code>O</code> of the access operation is computed as follows:

 
<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="../../../../resource-files/copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-java">O = this.offsetHandle(P).invokeExact(this.scale(B, I0), I1, I2, ... In);
</code></pre>
</div>

 <p>
 More formally, this method can be obtained from the <a href="#varHandle(java.lang.foreign.MemoryLayout.PathElement...)"><code>varHandle(PathElement...)</code></a>,
 as follows:
 
<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="../../../../resource-files/copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-java">MethodHandles.collectCoordinates(varHandle(elements), 1, scaleHandle())
</code></pre>
</div>
</div>
<dl class="notes">
<dt>API Note:</dt>
<dd>As the leading index coordinate <code>I0</code> is not bound by any sequence layout, it
 can assume <em>any</em> non-negative value - provided that the resulting offset
 computation does not overflow, or that the computed offset does not fall outside
 the spatial bound of the accessed memory segment. As such, the var handles
 returned from this method can be especially useful when accessing
 <a href="#variable-length">variable-length arrays</a>.</dd>
<dt>Parameters:</dt>
<dd><code>elements</code> - the layout path elements</dd>
<dt>Returns:</dt>
<dd>a var handle that accesses adjacent elements in a memory segment at
         offsets selected by the given layout path</dd>
<dt>Throws:</dt>
<dd><code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if the layout path is not
         <a href="#well-formedness">well-formed</a> for this layout</dd>
<dd><code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if the layout selected by the provided path is
         not a <a href="ValueLayout.html" title="interface in java.lang.foreign">value layout</a></dd>
</dl>
</div>
</section>
</li>
<li>
<section class="detail" id="sliceHandle(java.lang.foreign.MemoryLayout.PathElement...)">
<h3>sliceHandle</h3>
<div class="horizontal-scroll">
<div class="member-signature"><span class="return-type"><a href="../invoke/MethodHandle.html" title="class in java.lang.invoke">MethodHandle</a></span>&nbsp;<span class="element-name">sliceHandle</span><wbr><span class="parameters">(<a href="MemoryLayout.PathElement.html" title="interface in java.lang.foreign">MemoryLayout.PathElement</a>...&nbsp;elements)</span></div>
<div class="block">Creates a method handle which, given a memory segment, returns a
 <a href="MemorySegment.html#asSlice(long,long)">slice</a> corresponding to
 the layout selected by the given layout path, where the initial layout in
 the path is this layout.
 <p>
 The returned method handle has the following characteristics:
 <ul>
     <li>its return type is <code>MemorySegment</code>;</li>
     <li>it has a leading parameter of type <code>MemorySegment</code> corresponding to
     the memory segment to be sliced</li>
     <li>a following <code>long</code> parameter, corresponding to the base offset</li>
     <li>it has as zero or more trailing parameters of type <code>long</code>, one for
     each <a href=#open-path-elements>open path element</a> in the provided
     layout path. The order of these parameters corresponds to the order in which
     the open path elements occur in the provided layout path.
 </ul>
 <p>
 The offset <code>O</code> of the returned segment is computed as if by a call to a
 <a href="#byteOffsetHandle(java.lang.foreign.MemoryLayout.PathElement...)">byte offset handle</a> constructed
 using the given path elements.
 <p>
 Computing a slice of a memory segment using the method handle returned by this
 method is subject to the following checks:
 <ul>
     <li>The physical address of the accessed memory segment must be
     <a href="MemorySegment.html#segment-alignment">aligned</a> according to the
     <a href="#byteAlignment()">alignment constraint</a> of the root layout
     (this layout), or an <a href="../IllegalArgumentException.html" title="class in java.lang"><code>IllegalArgumentException</code></a> will be issued. Note
     that the alignment constraint of the root layout can be more strict
     (but not less) than the alignment constraint of the selected layout.</li>
     <li>The start offset of the slicing operation (computed as above) must fall
     inside the spatial bounds of the accessed memory segment, or an
     <a href="../IndexOutOfBoundsException.html" title="class in java.lang"><code>IndexOutOfBoundsException</code></a> is thrown. This is the case when
     <code>O + A &lt;= S</code>, where <code>O</code> is the start offset of
     the slicing operation (computed as above), <code>A</code> is the size of the
     selected layout and <code>S</code> is the size of the accessed memory segment.</li>
 </ul></div>
<dl class="notes">
<dt>API Note:</dt>
<dd>The returned method handle can be used to obtain a memory segment slice,
          similarly to <a href="MemorySegment.html#asSlice(long,long)"><code>MemorySegment.asSlice(long, long)</code></a>, but more flexibly,
          as some indices can be specified when invoking the method handle.</dd>
<dt>Parameters:</dt>
<dd><code>elements</code> - the layout path elements</dd>
<dt>Returns:</dt>
<dd>a method handle that is used to slice a memory segment at
         the offset selected by the given layout path</dd>
<dt>Throws:</dt>
<dd><code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if the layout path is not
         <a href="#well-formedness">well-formed</a> for this layout</dd>
<dd><code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if the layout path contains one or more
         <a href=#deref-path-elements>dereference path elements</a></dd>
</dl>
</div>
</section>
</li>
<li>
<section class="detail" id="select(java.lang.foreign.MemoryLayout.PathElement...)">
<h3>select</h3>
<div class="horizontal-scroll">
<div class="member-signature"><span class="return-type"><a href="MemoryLayout.html" title="interface in java.lang.foreign">MemoryLayout</a></span>&nbsp;<span class="element-name">select</span><wbr><span class="parameters">(<a href="MemoryLayout.PathElement.html" title="interface in java.lang.foreign">MemoryLayout.PathElement</a>...&nbsp;elements)</span></div>
<div class="block">Returns the layout selected from the provided path, where the initial layout in
 the path is this layout.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>elements</code> - the layout path elements</dd>
<dt>Returns:</dt>
<dd>the layout selected by the layout path in <code>elements</code></dd>
<dt>Throws:</dt>
<dd><code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if the layout path is not
         <a href="#well-formedness">well-formed</a> for this layout</dd>
<dd><code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if the layout path contains one or more
         <a href=#deref-path-elements>dereference path elements</a></dd>
<dd><code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if the layout path contains one or more path
         elements that select one or more sequence element indices, such as
         <a href="MemoryLayout.PathElement.html#sequenceElement(long)"><code>MemoryLayout.PathElement.sequenceElement(long)</code></a> and
         <a href="MemoryLayout.PathElement.html#sequenceElement(long,long)"><code>MemoryLayout.PathElement.sequenceElement(long, long)</code></a>)</dd>
</dl>
</div>
</section>
</li>
<li>
<section class="detail" id="equals(java.lang.Object)">
<h3>equals</h3>
<div class="horizontal-scroll">
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="element-name">equals</span><wbr><span class="parameters">(<a href="../Object.html" title="class in java.lang">Object</a>&nbsp;other)</span></div>
<div class="block">Compares the specified object with this layout for equality. Returns <code>true</code>
 if and only if the specified object is also a layout, and it is equal to this
 layout. Two layouts are considered equal if they are of the same kind, have the
 same size, name and alignment constraint. Furthermore, depending on the
 layout kind, additional conditions must be satisfied:
 <ul>
     <li>two value layouts are considered equal if they have the same
     <a href="ValueLayout.html#order()">order</a>, and
     <a href="ValueLayout.html#carrier()">carrier</a>. Additionally, two address
     layouts are considered equal if they also have the same
     <a href="AddressLayout.html#targetLayout()">target layout</a>;</li>
     <li>two sequence layouts are considered equal if they have the same element
     count (see <a href="SequenceLayout.html#elementCount()"><code>SequenceLayout.elementCount()</code></a>), and if their element
     layouts (see <a href="SequenceLayout.html#elementLayout()"><code>SequenceLayout.elementLayout()</code></a>) are also equal;</li>
     <li>two group layouts are considered equal if they are of the same type
     (see <a href="StructLayout.html" title="interface in java.lang.foreign"><code>StructLayout</code></a>, <a href="UnionLayout.html" title="interface in java.lang.foreign"><code>UnionLayout</code></a>) and if their member layouts
     (see <a href="GroupLayout.html#memberLayouts()"><code>GroupLayout.memberLayouts()</code></a>) are also equal.</li>
 </ul></div>
<dl class="notes">
<dt>Overrides:</dt>
<dd><code><a href="../Object.html#equals(java.lang.Object)">equals</a></code>&nbsp;in class&nbsp;<code><a href="../Object.html" title="class in java.lang">Object</a></code></dd>
<dt>Parameters:</dt>
<dd><code>other</code> - the object to be compared for equality with this layout</dd>
<dt>Returns:</dt>
<dd><code>true</code> if the specified object is equal to this layout</dd>
<dt>See Also:</dt>
<dd>
<ul class="tag-list">
<li><a href="../Object.html#hashCode()"><code>Object.hashCode()</code></a></li>
<li><a href="../../util/HashMap.html" title="class in java.util"><code>HashMap</code></a></li>
</ul>
</dd>
</dl>
</div>
</section>
</li>
<li>
<section class="detail" id="hashCode()">
<h3>hashCode</h3>
<div class="horizontal-scroll">
<div class="member-signature"><span class="return-type">int</span>&nbsp;<span class="element-name">hashCode</span>()</div>
<div class="block">Returns the hash code value for this layout.</div>
<dl class="notes">
<dt>Overrides:</dt>
<dd><code><a href="../Object.html#hashCode()">hashCode</a></code>&nbsp;in class&nbsp;<code><a href="../Object.html" title="class in java.lang">Object</a></code></dd>
<dt>Returns:</dt>
<dd>the hash code value for this layout</dd>
<dt>See Also:</dt>
<dd>
<ul class="tag-list-long">
<li><a href="../Object.html#equals(java.lang.Object)"><code>Object.equals(java.lang.Object)</code></a></li>
<li><a href="../System.html#identityHashCode(java.lang.Object)"><code>System.identityHashCode(java.lang.Object)</code></a></li>
</ul>
</dd>
</dl>
</div>
</section>
</li>
<li>
<section class="detail" id="toString()">
<h3>toString</h3>
<div class="horizontal-scroll">
<div class="member-signature"><span class="return-type"><a href="../String.html" title="class in java.lang">String</a></span>&nbsp;<span class="element-name">toString</span>()</div>
<div class="block">Returns the string representation of this layout.</div>
<dl class="notes">
<dt>Overrides:</dt>
<dd><code><a href="../Object.html#toString()">toString</a></code>&nbsp;in class&nbsp;<code><a href="../Object.html" title="class in java.lang">Object</a></code></dd>
<dt>Returns:</dt>
<dd>the string representation of this layout</dd>
</dl>
</div>
</section>
</li>
<li>
<section class="detail" id="paddingLayout(long)">
<h3>paddingLayout</h3>
<div class="horizontal-scroll">
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type"><a href="PaddingLayout.html" title="interface in java.lang.foreign">PaddingLayout</a></span>&nbsp;<span class="element-name">paddingLayout</span><wbr><span class="parameters">(long&nbsp;byteSize)</span></div>
<div class="block">Creates a padding layout with the given byte size. The alignment constraint of the
 returned layout is 1. As such, regardless of its size, in the absence of an
 <a href="#withByteAlignment(long)">explicit</a> alignment constraint, a padding
 layout does not affect the natural alignment of the group or sequence layout it is
 nested into.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>byteSize</code> - the padding size (expressed in bytes)</dd>
<dt>Returns:</dt>
<dd>the new selector layout</dd>
<dt>Throws:</dt>
<dd><code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if <code>byteSize &lt;= 0</code></dd>
</dl>
</div>
</section>
</li>
<li>
<section class="detail" id="sequenceLayout(long,java.lang.foreign.MemoryLayout)">
<h3>sequenceLayout</h3>
<div class="horizontal-scroll">
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type"><a href="SequenceLayout.html" title="interface in java.lang.foreign">SequenceLayout</a></span>&nbsp;<span class="element-name">sequenceLayout</span><wbr><span class="parameters">(long&nbsp;elementCount,
 <a href="MemoryLayout.html" title="interface in java.lang.foreign">MemoryLayout</a>&nbsp;elementLayout)</span></div>
<div class="block">Creates a sequence layout with the given element layout and element count.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>elementCount</code> - the sequence element count</dd>
<dd><code>elementLayout</code> - the sequence element layout</dd>
<dt>Returns:</dt>
<dd>the new sequence layout with the given element layout and size</dd>
<dt>Throws:</dt>
<dd><code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if <code>elementCount</code> is negative</dd>
<dd><code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if <code>elementLayout.byteSize() * elementCount</code>
         overflows</dd>
<dd><code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if <code>elementLayout.byteSize() % elementLayout.byteAlignment() != 0</code></dd>
</dl>
</div>
</section>
</li>
<li>
<section class="detail" id="structLayout(java.lang.foreign.MemoryLayout...)">
<h3>structLayout</h3>
<div class="horizontal-scroll">
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type"><a href="StructLayout.html" title="interface in java.lang.foreign">StructLayout</a></span>&nbsp;<span class="element-name">structLayout</span><wbr><span class="parameters">(<a href="MemoryLayout.html" title="interface in java.lang.foreign">MemoryLayout</a>...&nbsp;elements)</span></div>
<div class="block">Creates a struct layout with the given member layouts.</div>
<dl class="notes">
<dt>API Note:</dt>
<dd>This factory does not automatically align element layouts, by inserting
          additional <a href="PaddingLayout.html" title="interface in java.lang.foreign">padding layout</a> elements. As such,
          the following struct layout creation will fail with an exception:

 
<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="../../../../resource-files/copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-java">structLayout(JAVA_SHORT, JAVA_INT);
</code></pre>
</div>


 To avoid the exception, clients can either insert additional padding layout
 elements:

 
<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="../../../../resource-files/copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-java">structLayout(JAVA_SHORT, MemoryLayout.paddingLayout(2), JAVA_INT);
</code></pre>
</div>


 Or, alternatively, they can use a member layout that features a smaller alignment
 constraint. This will result in a <em>packed</em> struct layout:

 
<div class="snippet-container"><button class="copy snippet-copy" aria-label="Copy snippet" onclick="copySnippet(this)"><span data-copied="Copied!">Copy</span><img src="../../../../resource-files/copy.svg" alt="Copy snippet"></button>
<pre class="snippet"><code class="language-java">structLayout(JAVA_SHORT, JAVA_INT.withByteAlignment(2));
</code></pre>
</div>
</dd>
<dt>Parameters:</dt>
<dd><code>elements</code> - The member layouts of the struct layout</dd>
<dt>Returns:</dt>
<dd>a struct layout with the given member layouts</dd>
<dt>Throws:</dt>
<dd><code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if the sum of the <a href="#byteSize()">byte sizes</a>
         of the member layouts overflows</dd>
<dd><code><a href="../IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if a member layout in <code>elements</code> occurs at
         an offset (relative to the start of the struct layout) which is not
         compatible with its alignment constraint</dd>
</dl>
</div>
</section>
</li>
<li>
<section class="detail" id="unionLayout(java.lang.foreign.MemoryLayout...)">
<h3>unionLayout</h3>
<div class="horizontal-scroll">
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type"><a href="UnionLayout.html" title="interface in java.lang.foreign">UnionLayout</a></span>&nbsp;<span class="element-name">unionLayout</span><wbr><span class="parameters">(<a href="MemoryLayout.html" title="interface in java.lang.foreign">MemoryLayout</a>...&nbsp;elements)</span></div>
<div class="block">Creates a union layout with the given member layouts.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>elements</code> - The member layouts of the union layout</dd>
<dt>Returns:</dt>
<dd>a union layout with the given member layouts</dd>
</dl>
</div>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
<!-- ========= END OF CLASS DATA ========= -->
</main>
<footer role="contentinfo">
<hr>
<p class="legal-copy"><small><a href="https://bugreport.java.com/bugreport/">Report a bug or suggest an enhancement</a><br> For further API reference and developer documentation see the <a href="https://docs.oracle.com/pls/topic/lookup?ctx=javase22&amp;id=homepage" target="_blank">Java SE Documentation</a>, which contains more detailed, developer-targeted descriptions with conceptual overviews, definitions of terms, workarounds, and working code examples. <a href="https://docs.oracle.com/en/java/javase/index.html">Other versions.</a><br> Java is a trademark or registered trademark of Oracle and/or its affiliates in the US and other countries.<br> <a href="../../../../../legal/copyright.html">Copyright</a> &copy; 1993, 2024, Oracle and/or its affiliates, 500 Oracle Parkway, Redwood Shores, CA 94065 USA.<br>All rights reserved. Use is subject to <a href="https://www.oracle.com/java/javase/terms/license/java22speclicense.html">license terms</a> and the <a href="https://www.oracle.com/technetwork/java/redist-137594.html">documentation redistribution policy</a>. <!-- Version 22.0.2+9-70 --></small></p>
</footer>
</body>
</html>
